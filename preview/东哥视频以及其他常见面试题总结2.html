<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:东哥视频以及其他常见面试题总结2</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h3 id="-">东哥视频以及其他重要问题总结</h3>
<hr>
<p>[TOC]</p>
<hr>
<h5 id="let-for-">let和for循环</h5>
<ul>
<li><p>创建一个<code>for</code>循环,假如我们用<code>var</code></p>
<ul>
<li><p>循环变量<code>i</code>,,每次<code>i++</code></p>
</li>
<li><p>循环条件<code>i&lt;3</code></p>
</li>
<li><p>循环体,设置一定定时器,打印<code>i</code>的值</p>
<pre><code class="lang-jsx">for(var i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i)
  },50)
}
//3 
//3
//3
</code></pre>
</li>
</ul>
</li>
<li><p>我们发现结果是三个<code>3</code></p>
</li>
<li><p>?</p>
<ul>
<li>分析一下代码的执行过程<ul>
<li>在<code>js</code>中,定时器里面的回调函数是异步执行的<ul>
<li>异步事件会放在事件队列中</li>
<li>等待主程序全部执行完毕了</li>
<li>才会去执行</li>
<li>所以说<ul>
<li>即便定时器的时间是<code>0</code>,这个函数也不是立刻执行的</li>
</ul>
</li>
</ul>
</li>
<li>而<code>for</code>循环是主程序内容,会先执行</li>
<li>每次遇到设置定时器,都会将其中的回调函数放在事件队列中等待执行</li>
<li><code>for</code>循环执行完毕了,此时的<code>i</code>已经是<code>3</code>了</li>
<li>这个时候,定时器里面的回调函数执行,访问变量<code>i</code>,然而此时只有一个全局的<code>i为3</code>,打印出来全部都是<code>3</code></li>
</ul>
</li>
</ul>
</li>
<li><p>但是,假如我们使用<code>let</code>代替<code>var</code>,结果就会有大不同</p>
<pre><code class="lang-jsx">for(let i=0;i&lt;3;i++){
  setTimeout(function(){
    console.log(i)
  },50)
}
//0
//1
//2
</code></pre>
<ul>
<li><p><code>let</code>的本身相当于匿名函数自调用</p>
</li>
<li><p><code>let</code>遇到<code>for</code>循环后,会和<code>for</code>循环形成闭包</p>
<ul>
<li><p>这一点跟<code>var</code>很不同,<code>var</code>在<code>for</code>循环里,会不断刷新循环变量的值</p>
</li>
<li><p>准确来说</p>
<ul>
<li><p>let把每次循环变量<code>i</code>以及循环体都封装进一个闭包里面</p>
<ul>
<li>把循环体封装进匿名函数自调用里面</li>
<li>然后把本次循环变量<code>i</code>,当做参数传进来</li>
</ul>
</li>
<li><p>所以实际上,这段代码的执行过程其实就相当于</p>
<pre><code class="lang-jsx">for(var i=0;i&lt;3;i++){
    (function(i){
        setTimeout(function(){
    console.log(i)
  },50)
    })(i)
}
//0
//1
//2
</code></pre>
</li>
<li><p>所以当我们的主程序执行完毕后,定时器的回调函数使用的<code>i</code>都被装进了那次循环形成的闭包中,成为局部变量</p>
</li>
<li><p>因为在每次循环生成的闭包里,存在<code>i</code>,这个回调函数会直接使用这个<code>i</code></p>
</li>
<li><p>因此最终的答案是<code>0,1,2</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与之类似的,还有一个经典的问题</p>
<ul>
<li><p>通过循环,给页面上的5个<code>button</code>绑定点击事件,触发后分别打印<code>0,1,2,3,4</code></p>
<p><code>`</code>jsx</p>
<button onclick='fn()'></button>
<button onclick='fn()'></button>
<button onclick='fn()'></button>
<button onclick='fn()'></button>
<button onclick='fn()'></button>


</li>
</ul>
</li>
</ul>
<pre><code>var btns=document.querySelectorAll(&#39;button&#39;)
for(var i=0;i&lt;btns.length;i++){
  btns[i].onclick=function(){
    console.log(i)
  }
}
```

- 原理类似,如果我们使用`var`创建这个循环

- 每次循环,都会为当前`btn`绑定事件,但是因为这个事件函数还没有得到触发,因此根本不会管函数体里的内容

- 实际上,`for`循环生成的`i`,是一个全局变量,在循环外的全局都能访问得到

- `for`循环会瞬间完成,此时循环变量`i`已经是5



- `button`触发事件函数访问的是全局变量`i`,因此5个`button`打印结果都是5
</code></pre><ul>
<li><p>但是,如果我们通过匿名函数或者<code>let</code>的方式来改造这个循环,就能得到<code>1,2,3,4</code></p>
<pre><code class="lang-jsx">var btns=document.querySelectorAll(&#39;button&#39;)
for(let i=0;i&lt;btns.length;i++){
  btns[i].onclick=function(){
    console.log(i)
  }
}
</code></pre>
<ul>
<li>分析一下原理<ul>
<li>let相当于匿名函数自调用,会把每次的循环体和循环变量都装进来,形成闭包</li>
<li>因为在每次循环生成的闭包里,存在<code>i</code>,这个点击事件函数会直接使用这个<code>i</code>来进行打印</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>除此以外,<code>let</code>的其他特性</p>
<ul>
<li>不会声明提前</li>
<li>块级作用域,形成声明死区</li>
<li>和<code>var</code>一样可以只声明,不赋值,且可以重复赋值</li>
<li>但是<code>let</code>不可反复声明,已经用<code>let</code>声明的变量,不可再次声明</li>
</ul>
</li>
<li><p>与<code>let</code>同时提出的<code>const</code>的特性</p>
<ul>
<li>不会声明提前</li>
<li>声明时必须进行初始化(也就是说必须赋值)</li>
<li><code>const</code>,声明的是常量,所谓常量一经声明就不可以发生变化<ul>
<li>不可再次声明</li>
<li>不可再次赋值</li>
</ul>
</li>
<li>习惯上,常量名大写</li>
</ul>
</li>
</ul>
<h5 id="-">对象的深浅拷贝</h5>
<ul>
<li><p>何时</p>
<ul>
<li>有时候我们需要创建一个引用类型对象的副本</li>
<li>二者结构应完全相同</li>
<li>副本和原件相互独立,改动其中之一时,另一个不受影响</li>
</ul>
</li>
<li><p>难点</p>
<ul>
<li><p>在<code>js</code>中原始类型赋值按值传递,但是引用类型赋值是<strong>按其在内存里的地址</strong>传递的</p>
<ul>
<li>所以直接赋值的话,不叫拷贝</li>
<li>因为这样的话,二者指向同一个地址</li>
<li>只要二者其一发生改变,另一个也会跟着变</li>
<li>比如</li>
</ul>
<pre><code class="lang-jsx">let obj={
  uname:&#39;tom&#39;
  age:4
}
let obj2=obj
obj2.age=3
console.log(obj)  //uname:&#39;tom&#39; age:3
</code></pre>
<ul>
<li>实际上<code>obj</code>和<code>obj2</code>只不过都是同一个内存地址的<strong>两个别名</strong>罢了</li>
</ul>
</li>
<li><p>因此不能采用这个方式进行拷贝</p>
</li>
</ul>
</li>
<li><p>浅拷贝</p>
<ul>
<li><p>适用于那种简单的对象,也就是每一项都是原始类型,不涉及到数组或对象嵌套的那种</p>
</li>
<li><p>遍历对象,把对象的每一项,交给一个新对象</p>
<pre><code class="lang-jsx">let obj={
  uname:&#39;tom&#39;,
  age:4
}
let obj2={}
for(let key in obj){
  obj2[key]=obj[key]
}
obj2.age=3
console.log(obj) //{uname: &quot;tom&quot;, age: 4}
</code></pre>
<ul>
<li><p>拷贝成功,此时两者其一修改了,另一方不会受到影响</p>
</li>
<li><p>但是,这样依旧存在问题</p>
<ul>
<li>但是如果我们拷贝的对象是包含 <strong>数组或者对象嵌套</strong> 的复杂对象的话,这个方法就不管用了</li>
<li>因为即使是<strong>对象</strong> 内层的 <strong>子对象</strong> 也是一个引用类型 ,采用<code>obj2[key]=obj[key]</code>这种赋值的方式,依旧会导致二者互相影响</li>
<li>比如,浅拷贝之后修改<code>obj2</code>的某个子对象后<code>obj</code>本身也会受到影响</li>
</ul>
<pre><code class="lang-jsx">let obj={
  uname:&#39;tom&#39;,
     msg:{
    age:4,
    gender:0
  }
}
let obj2={}
for(let key in obj){
  obj2[key]=obj[key]
}
obj2.msg.age=3
console.log(obj)  //uname: &quot;tom&quot;  msg: {age: 3, gender: 0}
</code></pre>
</li>
<li><p>所以,只要对象的某个属性还是一个 <strong>引用类型</strong> 的话,就需要使用 <strong>深拷贝</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li><p>何时 : 如果对象的某个属性还是 <strong>引用类型</strong> 时,<strong>浅拷贝</strong>显然已经无法满足需求,需要采用<strong>深拷贝</strong>的方式</p>
</li>
<li><p>原理</p>
<ul>
<li><p>和浅拷贝类似</p>
</li>
<li><p>只是多了一个环节</p>
<ul>
<li><p>判断对象每个属性是引用类型还是原始类型</p>
<ul>
<li>原始类型直接赋值,按值传递</li>
<li>引用类型就 <strong>递归</strong> 调用这个方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    ```jsx
    let obj={
      uname:&#39;tom&#39;,
         msg:{
        age:4,
        gender:0
      }
    }

    function clone(obj){
      var obj2={}
      for(var key in obj){
        if(typeof(obj[key])!==&#39;object&#39;){
          obj2[key]=obj[key]
        }else{
          obj2[key]=clone(obj[key])
        }
      }
      return obj2
    }
    var obj2=clone(obj)
    obj2.msg.age=2
    console.log(obj)
    ```

    * 但是,单单做到这样是不够的

      * 数组也是**引用类型**,但是数组不应该通过`for in`的形式进行遍历,否则不能达成我们的效果
      * 可能会遇到`null`等情况

    * 所以在执行之前还需进行一步判断

      * 如果是数组,则调用克隆数组的方式

        ```jsx
        {}.toString.call(要判断的内容)  //可判断传入内容的类型
        ```

      * 如果是`null`,直接`return null`

        ```jsx
        let obj={
          uname:&#39;tom&#39;,
          family:[2,3,5],
             msg:{
            age:4,
            gender:0
          }
        }

        function clone(obj){
          if(obj==null){
            return null
          }
          if({}.toString.call(obj)==&#39;[Object Array]&#39;){
            return obj.slice()  //slice不写参数代表从开头到最后
          }
          var obj2={}
          for(var key in obj){
            if(typeof(obj[key])!==&#39;object&#39;){
              obj2[key]=obj[key]
            }else{
              obj2[key]=clone(obj[key])
            }
          }
          return obj2
        }
        var obj2=clone(obj)
        obj2.msg.age=2
        obj2.family[2]=&#39;232&#39;
        console.log(obj)
        ```
</code></pre><ul>
<li><p>这种深拷贝采用 <strong>递归</strong> 方式达成条件</p>
</li>
<li><p>但是递归比较消耗性能,对于涉及多层嵌套的对象,可能会导致<strong>栈溢出</strong>的问题</p>
</li>
<li><p>了解</p>
<ul>
<li><p>沙雕网友的写法,过程比较复杂,原理是用循环来写</p>
<pre><code class="lang-jsx">function cloneForce(x) {
  //拷贝对象记录
  const uniqueList = []; 

  let root = {};

  // 循环数组
  const loopList = [{
    parent: root,
    key: undefined,
    data: x,
  }];

  while (loopList.length) {
    //深拷贝，元素出栈
    const node = loopList.pop();
    const parent = node.parent;
    const key = node.key;
    const data = node.data;

    let res = parent;
    if (typeof key !== &#39;undefined&#39;) {
      res = parent[key] = {};
    }

    // 判断数据是否存在
    let uniqueData = find(uniqueList, data);、
    //数据存在
    if (uniqueData) {
      parent[key] = uniqueData.target;
      break; // 中断本次循环
    }

    //数据不存在，将其放入数组
    uniqueList.push({
      source: data,
      target: res,
    });

    for (let k in data) {
      if (data.hasOwnProperty(k)) {
        if (typeof data[k] === &#39;object&#39;) {
          // 下一次循环
          loopList.push({
            parent: res,
            key: k,
            data: data[k],
          });
        } else {
          res[k] = data[k];
        }
      }
    }
  }

  return root;
}

function find(arr, item) {
  for (let i = 0; i &lt; arr.length; i++) {
    if (arr[i].source === item) {
      return arr[i];
    }
  }

  return null;
}

</code></pre>
</li>
</ul>
</li>
<li><p>如果是数组的拷贝</p>
<ul>
<li>其实更简单</li>
<li>上面提到过,使用<code>slice()</code>进行切割,会返回一个全新地址的新数组</li>
<li>深拷贝的话,判断数组的内容,再执行响应的操作即可</li>
</ul>
</li>
</ul>
<h5 id="-">数组的扁平化(降维)</h5>
<ul>
<li><p>存在一个多维嵌套的数组,把这个数组打散为一维数组</p>
</li>
<li><p>最简单办法</p>
<ul>
<li><p><code>toString()</code>方法</p>
<ul>
<li><code>toString</code>对数组使用,会把数组打散为一维数组字符串</li>
<li>然后再使用<code>split</code>把这个字符串改为数组即可</li>
</ul>
<pre><code class="lang-jsx">let arr=[1,2,3,[4,5,[6,7]],8,9]
let newArr=arr.toString().split(&#39;,&#39;)
console.log(newArr)
</code></pre>
<ul>
<li>但是得到的是一个字符数组<ul>
<li>虽然可以遍历每一项将其转为<code>Number</code></li>
<li>但是原数组如果是 <strong>普通数字</strong> 和 <strong>字符数字</strong> 混用的话, 我们将其<code>toString()</code>后就无从判断了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ES6办法</p>
<ul>
<li><p><code>ES6</code>有提供专门用于处理数组降维的<code>api</code></p>
<pre><code class="lang-jsx">arr.flat(&#39;数组深度&#39;)
</code></pre>
<ul>
<li><p>假如数组是三维数组,深度就写<code>2</code>,以此类推</p>
</li>
<li><p>如果不知道深度多少,或者懒得自己算了,直接写<code>Infinity</code></p>
<pre><code class="lang-jsx">let arr=[1,2,3,[4,5,[6,7]],8,9].flat(Infinity)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最经典、最传统办法 ( 其实就是手写flat方法 )</p>
<ul>
<li><p>原理</p>
<ul>
<li>声明一个新数组</li>
<li>写一个方法<ul>
<li>遍历原数组的每一项</li>
<li>如果不是数组,直接放进新数组里</li>
<li>如果是数组,就对这个子数组 <strong>递归 </strong>地调用这个方法,直到不是数组为止</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">let arr=[1,2,3,[4,5,[6,7]],8,9],arr2=[]
function myFlat(arr){
  arr.forEach(item=&gt;{
    ({}.toString).call(item)==&#39;[object Array]&#39;?myFlat(item):arr2.push(item)
  })
}
myFlat(arr)
console.log(arr2)
</code></pre>
</li>
</ul>
</li>
<li><p>其他方法</p>
<ul>
<li><p>使用<code>some</code>配合<code>isArray</code>方法</p>
</li>
<li><p>原理和上面类似</p>
<ul>
<li>遍历数组</li>
<li>只要该数组的某个元素还是数组</li>
<li>就对当前数组展开一次<ul>
<li><code>...arr</code>会把<code>arr</code>数组进行打散</li>
<li><code>[]+...arr</code> 会把<code>arr</code>打散的新数组拼接为一个新数组</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">let arr=[1,2,3,[4,5,[6,7]],8,9]
while(arr.some(item=&gt;Array.isArray(item))){
  arr=[].concat(...arr)
}
console.log(arr)
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="-vue-">模拟实现Vue的双向绑定</h5>
<ul>
<li><p>vue数据绑定原理</p>
<ul>
<li><p>改造<code>data</code>中对象的属性,并且保护每个属性</p>
<ul>
<li>将<code>data</code>中的数据隐姓埋名半隐藏</li>
<li>为每个属性提供一对<code>get</code>,<code>set</code>方法进来属性保护</li>
</ul>
<pre><code class="lang-jsx">//改造data
var data={
  uname:&#39;tom&#39;,
  upwd:&#39;123456&#39;,
  gender:0
}
//拿到data中的所有的key值
var keys=Object.keys(data)
//此时要使用let 或者自己封装一个匿名函数,用var会不断刷新key的值
for(var key in keys){
  ~function(key){
    Object.defineProperties(data,{
    //动态生成的属性名,要写在[]里,直接拼接字符串是不能用的
    [`_`+key]:{
      value:data[key],
      writable:true,
      enumerable:false
    },
    [key]:{
      get(){return this[`_`+key]},
      set(value){
        this[`_`+key]=value
        console.log(`${key}的属性值变了`)
        //只要发生变化,就自动调用这个change()方法
        change(key)
      }
    },
    enumerable:true
  })
  }(key)
}
//将我们的数据密封起来
Object.seal(data)
console.log(data)
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>扫描真实<code>DOM</code>树,把有<code>{{}}</code>的地方和<code>data</code>中的数据对应,构建<code>虚拟DOM</code>树</p>
<ul>
<li>构建虚拟<code>DOM</code>树,并完成首次绑定内容</li>
<li>准备数组保存所有可能变化的元素</li>
<li>扫描父元素下是否还有其他子元素</li>
<li>如果有,就递归执行这个方法</li>
<li>否则,就说明当前元素只有内容,并没有嵌套其他的元素节点</li>
<li>每遍历一次,就用当前元素的内容和<code>data</code>中的属性名比较</li>
<li>如果<code>data</code>中有这个内容,才有必要将这个元素添加到虚拟<code>DOM</code>树的数组里<ul>
<li>虚拟<code>DOM</code>中的每个元素,不但要记录<code>DOM</code>的地址</li>
<li>还要记录这个<code>DOM</code>元素哪个属性发生了变化,打算变成哪个变量的值</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">var arr=[]
function getChildren(parent){
  var children=parent.children
  for(var child of children){
    if(child.children.length&gt;c){
      arguments.callee(child)
    }else{
      for(var key of keys){
        if(child.innerHTML==`{{${key}}}`)
          arr.push({
            elem:child,
            innerHTML:child.innerHTML
          })
      }
    }
  }
}
getChildren(document.body)
</code></pre>
<ul>
<li>除此以外,还需要根据本次变化的属性,查找<code>虚拟DOM</code>中受到影响的节点,更新真实<code>DOM</code>树中该节点的内容<ul>
<li>每次调用<code>set</code>函数时候,触发这个方法</li>
<li>判断在不在虚拟<code>DOM树</code>上</li>
<li>为对应的真实<code>DOM</code>更新值</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">function change(){
  for(var obj of arr){
    if(obj.innerHTMl==`{{${key}}}`){
      obj.elem.innerHTML=data[key]
    }
  }
}
</code></pre>
</li>
</ul>
<h5 id="-">节流和防抖</h5>
<ul>
<li><p>防抖</p>
<ul>
<li><p>是什么</p>
<ul>
<li>事件在<code>n</code>秒内连续触发,就不能得到执行的操作</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>事件发动时,先不触发函数,而是先读定时器</li>
<li>事件每次触发时,都会不断地刷新重置定时器</li>
<li>因为定时器被不断重置,因此函数也不会得到执行</li>
<li>直到用户停止了操作,在一个定时器的时间后,这个方法就会得到执行</li>
</ul>
</li>
<li><p>何时使用</p>
<ul>
<li>比如一个购物车商品数量的加减按钮，用户修改数量后，这个数据要同步给后台。但是于此同时，如果用户每次点击这个按钮都发送一次请求的话，就没有必要了，这种情况就可以利用这个技术</li>
<li>与上面类似的，假如实现一个类似百度的输入框输入功能，会监控我们的输入行为，每次输入都会根据我们输入的关键词，给予提示但是不能每输一个字就不断地调用这个函数发送请求，所以也要使用这个技术，只有用户暂停输入了，才会发送请求</li>
</ul>
</li>
<li><p>如何</p>
<pre><code class="lang-jsx">function fun(){
    let foo=function(){
        console.log(&#39;防抖&#39;)
    }
    let timer=null
    return ~function(){
    clearTimeout(timer)
    timer=setTimeout(()=&gt;{
    foo().call();
    },2000)
}()
}
</code></pre>
<ul>
<li>利用闭包机制,声明一个<code>timer</code>来控制定时器</li>
<li>事件每次执行都会先清除定时器</li>
<li>然后再重设这个定时器</li>
<li>如果用户短时间内不断地执行这个函数,定时器就会被不断地<strong>清除和重设</strong></li>
<li>只有用户停止操作了,经一个定时器单位的时长后,事件可以被触发</li>
<li><code>call和apply</code>不但能改变<code>this</code>指向跟传参,还能让函数立刻执行<ul>
<li>与之相对应的还有<code>bind</code>,<code>bind</code>是一种函数预处理机制<ul>
<li>可以永久替换<code>this</code>指向</li>
<li>可以传参</li>
<li>同时不调用这个函数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>节流</p>
<ul>
<li><p>是什么</p>
<ul>
<li>事件在<code>n</code>秒内,只能触发一次,会稀释这个函数的执行频率</li>
</ul>
</li>
<li><p>原理以及使用方法</p>
<ul>
<li>通过闭包保存一个控制函数是否可以执行的状态<code>bool</code>变量</li>
<li>第一次时,我们的函数执行完毕,并且把<code>bool</code>修改为<code>false</code></li>
<li>此时<code>bool</code>会在<code>3s</code>内一直都是<code>false</code></li>
<li>期间,我们每次调用这个方法,都会被直接<code>return</code>,不会执行</li>
<li>直到<code>3s</code>到了,这个<code>bool</code>会被重新定义为<code>true</code></li>
<li>此时才可以再次触发这个函数</li>
</ul>
<pre><code class="lang-jsx">function fun(){
    let foo=function(){
        console.log(&#39;节流&#39;)
    }
    let bool=true
    return ~function(){
        if(!bool)return
        bool=false
        timer=setTimeout(()=&gt;{
        foo().call()
        bool=true
        },500)
        }()
}
</code></pre>
<ul>
<li>同样,需要使用<code>call()</code>,这里并不是为了改变<code>this</code>指向,而是单纯让函数立刻执行 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-a-1a-2a-3-">满足a==1&amp;&amp;a==2&amp;&amp;a==3同时成立</h5>
<ul>
<li><p>方法一</p>
<ul>
<li><p>利用和数值型进行 <strong>比较判断</strong> 时候的原理</p>
<ul>
<li>引用类型和数值型进行比较的时候，会调用其原型上的<code>toString()</code>方法，将引用类型先转为字符串，然后再和数字型比较</li>
<li>根据原型链的原理<ul>
<li>访问某个对象的成员时,会优先查找这个对象的自有成员</li>
<li>自有成员中没有这个方法,会去自己的原型<code>__proto__</code>上面找</li>
<li>如果在没有会沿着原型链,去上级原型上找</li>
<li>以此类推,直至顶层还没有,返回<code>null</code></li>
</ul>
</li>
<li><code>toString</code>方法本应在一个对象的原型上,但是如果我们把它写为这个对象的自有方法,那么在尽心调用时,它就会优先访问这个自有方法</li>
</ul>
<pre><code class="lang-jsx">let a={
  a:0,
  toString(){
   return ++this.a
  }
}
a==1&amp;&amp;a==2&amp;&amp;a==3
</code></pre>
<ul>
<li>我们来分析一下这段代码的执行过程<ul>
<li>首先会判断<code>a==1</code><ul>
<li>因为我们的<code>a</code>是一个对象,不能直接做比较</li>
<li>会调用<code>a</code>的<code>toSting</code></li>
<li>因为我们手写了一个<code>a</code>的该方法,有了自有方法,不再会去原型上找默认方法</li>
<li>因此,这次执行结果我们返回了 <code>0++</code>,也就是<code>1</code></li>
</ul>
</li>
<li>同理,我们又先后两次调用了<code>toString</code>方法<ul>
<li>分别返回了<code>1++,和2++</code></li>
</ul>
</li>
<li>因此最终的结果才能为<code>true</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与之同理的还有第二个方法</p>
<ul>
<li><p>与对象同理,数组在和数值类进行比较的时候,也会调用<code>toString</code>方法,先转为字符串</p>
</li>
<li><p>我们给数组写一个自有方法<code>toString</code>,这样调用数组的<code>toString</code>时,就会优先使用自有方法</p>
<pre><code class="lang-jsx">let a=[1,2,3]
a.toString=a.shift
a==1&amp;&amp;a==2&amp;&amp;a==3
</code></pre>
<ul>
<li><p>数组的<code>shift</code>方法是操作原数组,移除数组<strong>首位元素</strong>,并且将删除的那位返回出来</p>
</li>
<li><p>基于此,我们分析一下代码的执行过程</p>
<ul>
<li><p>先会判断<code>a==1</code>,调用<code>toString</code>,但是因为我们用<code>shift</code>方法赋值了<code>toString</code>,实际上相当于</p>
<pre><code class="lang-jsx">[1,2,3].shift==1
</code></pre>
<pre><code class="lang-jsx">//也就是
&#39;1&#39;==1
</code></pre>
</li>
<li><p>之后判断,<code>a==2和a==3</code>时候,也是这个原理</p>
<pre><code class="lang-jsx">true&amp;&amp;&#39;2&#39;==2
</code></pre>
<pre><code class="lang-jsx">true&amp;&amp;true&amp;&amp;&#39;3&#39;==3
</code></pre>
</li>
<li><p>因此最终结果是<code>true</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我们还可以通过访问器属性来实现这个需求</p>
<ul>
<li><p>如果我们给一个对象进行<code>defineProperty</code>属性保护</p>
</li>
<li><p>每次我们访问这个属性时,都会调用其<code>get</code>方法</p>
</li>
<li><p>每次我们修改这个属性时,都会调用其<code>set</code>方法</p>
<pre><code class="lang-jsx">Object.defineProperty(window,&#39;a&#39;,{
  get(){
    this.value?this.value++:this.value=1
    return this.value
  }
})
a==1&amp;&amp;a==2&amp;&amp;a==3
</code></pre>
<ul>
<li>分析这段代码的执行过程<ul>
<li>首先因为进行判断的<code>a</code>是全局变量,其实也就是<code>window.a</code></li>
<li>所以我们给<code>window.a</code>设置属性保护</li>
<li>当我们访问这个<code>a</code>时候,触发内置的<code>get</code>方法<ul>
<li>如果存在<code>value</code>值,就让<code>value++</code></li>
<li>不存在,就让<code>value=1</code></li>
<li>把<code>value</code>返回出去</li>
</ul>
</li>
<li>我们每次进行比较的时候,都会访问<code>a</code>,从而触发访问器属性的<code>get</code>方法<ul>
<li><code>get</code>方法三次分别返回出<code>1,2,3</code></li>
</ul>
</li>
<li>因此结果为<code>true</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-hoist">作用域、作用域链和hoist</h5>
<ul>
<li><p>作用域?</p>
<ul>
<li>作用域其实就是一个 <strong>变量</strong> 的有效使用范围</li>
<li>分为<ul>
<li>函数作用域<ul>
<li>函数的私有变量,只能在函数里才能访问得到</li>
<li>函数在调用时,会临时生成<strong>函数作用域对象</strong>,保存这次函数调用里面的<strong>私有变量</strong><ul>
<li>形参</li>
<li>函数内声明的变量</li>
</ul>
</li>
<li>函数访问某个变量时,只要函数作用域对象里有相应的私有变量,就不会沿着作用域链去上层找</li>
<li>函数调用后,本次调用所形成的作用域对象就被销毁,不复存在</li>
<li>每次函数调用形成的作用域对象,互相独立,互不干扰</li>
</ul>
</li>
<li>全局作用域<ul>
<li>在全局声明的变量</li>
<li>一次声明,全局可用,随时可用</li>
<li>但是容易出现全局污染</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>作用域链</p>
<ul>
<li><p>控制当我们访问一个变量时顺序的链状结构</p>
</li>
<li><p>在一个函数内</p>
<ul>
<li>优先访问私有变量,只要有私有变量就不会访问外部的<ul>
<li>就一个函数而言,私有变量就是 <strong>在函数内声明</strong> 的变量,以及<strong>形参</strong></li>
</ul>
</li>
<li>如果没有沿着作用域链往上找</li>
<li>直到找到<code>window</code>都没有,返回<code>undefined</code></li>
</ul>
</li>
<li><p>如果在一个函数内,既有形参<code>a</code>,又有用<code>var</code>声明的变量<code>a</code>,究竟用哪个</p>
<pre><code class="lang-jsx">var a=5
function fn(a){
  var a=10;
  a+=20
  console.log(a)
}
fn(a)
console.log(a)
</code></pre>
<ul>
<li>模拟一下这个函数的执行过程<ul>
<li>调用函数,并且传入<strong>实参</strong><code>5</code><ul>
<li>原始类型,按值传递,只是用了外部的<code>a</code>赋值了函数内部的形参<code>a</code></li>
<li>无论函数内对<code>a</code>进行了怎样的操作,都和外部的<code>a</code>无关</li>
</ul>
</li>
<li>因为在函数内,已经存在私有变量<code>a</code>(形参)</li>
<li>因此<code>var a</code>不会生效<ul>
<li><code>js</code>不会重复声明当前作用域已经存在的变量</li>
</ul>
</li>
<li>但是赋值<code>a=10</code>保留</li>
<li>随后<code>a+=20</code></li>
<li>所以最后的答案是<code>30和5</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一些例题以及代码分析</p>
<pre><code class="lang-jsx">1.
var b=10
function fn(){
  b+=1
  var b=100
}
fn()
console.log(b)
</code></pre>
<ul>
<li><p>分析一下代码的执行过程</p>
<ul>
<li><p>在全局声明变量<code>b</code>,声明提前,赋值留在原地</p>
</li>
<li><p>在函数内,<code>var</code>声明的变量,会提升到当前作用域最前面,赋值留在原地,函数的执行过程相当于</p>
<pre><code class="lang-jsx">function(){
    var b   
  b+=1
  b=100
}
</code></pre>
<ul>
<li>先是声明一<code>b</code>,但是没赋值,所以值是<code>undefined</code></li>
<li><code>b+=1</code>,因为在函数作用域内存在<code>b</code>私有变量,所以不会使用全局的变量,未定义的值<code>+1</code>,是<code>NaN</code></li>
<li>最后给<code>b</code>赋值100</li>
<li>从始到终,函数内部的操作都和外部<code>b</code>无关,因此外部的值为<code>10</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">2.
var c=10
function fun(c){
  c=100
  c+=1
}
fun(c)
console.log(c)
</code></pre>
<ul>
<li><p>分析代码的执行过程</p>
<ul>
<li><p>在全局中声明变量<code>c</code>,声明提前,赋值留在原地</p>
</li>
<li><p>经声明提前处理后的整个代码</p>
<pre><code class="lang-jsx">var c
function fun(c){
  c=100
  c+=1
}
c=10
fun(c)
console.log(c)
</code></pre>
<ul>
<li>我们将外部全局的<code>c</code>传入其中,按值传递,相当于给形参<code>c</code>赋值为<code>10</code></li>
<li>在函数内,因为存在私有变量<code>c</code>,因此任何操作都和外部的<code>c</code>无关</li>
<li>所以外部的<code>c</code>最终还是10</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>`</code>jsx
3.
function fn(){
  console.log(1)
}
fn()</p>
</li>
</ul>
<p>  function fn(){
    console.log(2)
  }
  fn()</p>
<p>  var fn=100
  fn()</p>
<pre><code>
  * 分析这段代码的执行过程

    * 函数声明和`var`声明都会在编译时提升到作用域最前面
    * 于是这段代码其实相当于

    ```jsx
    function fn(){
      console.log(1)
    }
    function fn(){
      console.log(2)
    }
    var fn
    fn()
    fn()
    fn=100
    fn()
</code></pre><pre><code>* 函数其实也是对象,函数名其实就是一个普通的变量名
* `function`关键字其实就是创建一个函数对象,并把对象的地址交给`fn`来保存
* 之后我们又声明了一个同名函数对象,因为内存中已经存在了`fn`,不会再次声明,但是会用新函数对象的地址覆盖旧的值
* `var fn`时,因为已经存在`fn`了,不会再重复创建,此代码相当于无效
* `fn()`执行,此时`fn`保存的是我们第二次声明的函数对象,所以结果是`2`
* `fn()`执行,此时`fn`保存的依旧是我们第二次声明的函数对象,没有变化,所以结果是`2`
* 之后我们给`fn`赋值为`100`,覆盖了原先的函数对象
* 再次调用`fn`,此时`fn`只是一个数值,而不是函数,因此会报错,提示`fn不是一个方法`
</code></pre><pre><code class="lang-jsx">  4.把3改为如下,分析结果
  var fn=function(){
    console.log(1)
  }
  fn()


  var fn=function(){
    console.log(2)
  }
  fn()


  var fn=100
  fn()
</code></pre>
<ul>
<li><p>分析代码执行过程</p>
<ul>
<li>先是处理声明提前机制,代码相当于</li>
</ul>
<pre><code class="lang-jsx">var fn
var fn 
var fn
fn=function(){console.log(1)}
fn()
fn=function(){console.log(2)}
fn()
fn=100
fn()
</code></pre>
<ul>
<li>首先声明了一个<code>fn</code></li>
<li>因为已经存在了一个<code>fn</code>了,所以后两个<code>var</code>无效</li>
<li>接着给<code>fn</code>赋值一个函数的地址<ul>
<li>当使用<code>var</code>声明函数时,只有函数名会提前,函数本身并不提前</li>
</ul>
</li>
<li>此时调用函数,结果就是<code>1</code></li>
<li>再给<code>fn</code>赋值一个函数对象的地址,覆盖了之前的</li>
<li>此时调用函数,结果就是<code>2</code></li>
<li>给<code>fn</code>赋值<code>100</code></li>
<li>此时<code>fn</code>已经不再指向一个函数对象,而是普通的数值</li>
<li>因此没办法被当成函数来调用</li>
<li>报错<code>fn is not a function</code></li>
</ul>
<pre><code class="lang-jsx">5.
var a=10
function fun(){
a=100
a+=1
console.log(a)
}
fun();
console.log(a)
</code></pre>
</li>
<li><p>详细分析代码执行</p>
<ul>
<li>在全局声明一个变量<code>a</code></li>
<li>我们调用函数<code>fun</code>,此时就会生成一个函数作用域对象</li>
<li>但是因为函数内没有一个形参<code>a</code>或者声明的变量<code>a</code></li>
<li>所以函数作用域对象是空的</li>
<li>此时我们在函数里,访问<code>a</code>,会沿着作用域链向上找</li>
<li>找到了全局的<code>a</code></li>
<li>全局的<code>a</code>最终被修改为了<code>101</code></li>
<li>无论函数内外,<code>a</code>的打印都是<code>101</code></li>
</ul>
</li>
</ul>
<h5 id="-">闭包</h5>
<ul>
<li><p>是什么</p>
<ul>
<li>外层函数的作用域对象，因为被内层函数引用着，而无法的得到释放,我们把这个无法得到释放的作用域对象称为闭包</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>在<code>js</code>中，全局变量虽然一次声明全局可用，但是极容易被污染；</li>
<li>而函数内的变量，虽然不会被污染，但是几乎不可复用，函数一经调用完毕，就会被垃圾回收</li>
<li>闭包就是这样一种机制<ul>
<li>既保护变量不受到污染,闭包对象在全局无从篡改</li>
<li>同时又可让这个变量得到复用</li>
</ul>
</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>外层函数调用后,会形成自己的作用域对象</li>
<li>这个作用域对象因为被内层函数引用着,无法释放,形成闭包</li>
<li>内层函数调用时,会优先使用自己的变量,自己没有,才去外层的作用域对象里找</li>
<li>内层函数在调用后,只会释放自己,但是无法释放外层的作用域对象,使得外部作用域对象一直存在</li>
<li>因为外部函数的变量并没有保存在全局,所以在函数外绝无篡改可能 ! </li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>消耗性能,比普通函数多占用一块内存空间</li>
</ul>
</li>
<li><p>分析一段代码</p>
<pre><code class="lang-jsx">function parent(){
  var total=1000
  return function(money){
    total-=money
    console.log(total)
  }
}
var pay=parent()
pay(100)
total=0
pay(100)
pay(100)
</code></pre>
<ul>
<li><code>parent</code>调用时,临时创建 作用域对象 , 保存这个函数的私有变量</li>
<li>首先我们把<code>parent()</code>的执行结果(也就是<code>return</code>出来的那部分),交给<code>pay</code>来保存</li>
<li>一般来说,函数在调用一次后就被释放,作用域对象也会被释放,但是因为内层函数引用着外层函数的变量<code>total</code>,因此外层函数并没有得到释放</li>
<li>调用<code>pay()</code>函数的时候,用到了变量<code>total</code><ul>
<li>先在自有的作用域对象里查找<code>total</code></li>
<li>发现没有,沿着作用域链去外层函数的作用域对象里找</li>
<li>对外层函数的变量<code>total</code>进行了修改操作<ul>
<li>假如,我是说假如外层函数的作用域对象也没有这个变量,才会去<code>window</code>中找</li>
</ul>
</li>
<li>而<code>total=0</code>是针对全局变量<code>total</code>进行的操作,和函数内的<code>total</code>无关,闭包里的变量从全局无从篡改</li>
</ul>
</li>
<li>因此得到结果<code>900 800 700</code></li>
<li>这样一来,既保证了变量的复用,又使得变量在函数里,不会受到全局污染</li>
</ul>
</li>
<li><p>闭包习题</p>
<pre><code class="lang-jsx">var number=2
var obj={
  number:4,
  fn:(function(){
    this.number*=2;
    number*=2;
    var number=3;
    return function(){
      this.number*=2
      number*=3
      console.log(number)
    }
  })()
}
var fn=obj.fn
console.log(number)
fn()
obj.fn()
console.log(number)
console.log(obj.number)
</code></pre>
<ul>
<li><p>分析代码执行</p>
<ul>
<li><p><code>obj.fn</code>存储的只是一个 <strong>自调用的匿名函数的地址</strong> ,这个函数会在自动调用后,将返回结果交于<code>obj.fn</code>保存</p>
</li>
<li><p>首先分析这个匿名函数自调用</p>
<ul>
<li><p>首先<code>var number</code>,声明提前,赋值留在原地</p>
</li>
<li><p><code>this.number*=2</code></p>
<ul>
<li>匿名函数的<code>this</code>指向<code>window</code>,因此全局的<code>number</code>修改为<code>4</code></li>
</ul>
</li>
<li><p><code>number*=2 num=3</code></p>
<ul>
<li>最终函数内的<code>number</code>被赋值为<code>3</code></li>
</ul>
</li>
<li><p>我们把函数<code>return</code>的部分交给<code>obj:fn保存</code></p>
<pre><code class="lang-jsx">obj:{
  number:4,
    fn: function(){
      this.number*=2
      number*=3
      console.log(number)
    }
}
</code></pre>
</li>
<li><p>但是外层函数的作用域对象因为被<code>obj.fn</code>牵引着,并没有得到释放</p>
</li>
</ul>
</li>
<li><p><code>var fn=obj.fn</code>,实际上就相当于</p>
<ul>
<li>函数是引用类型,传值传的是在内存中的地址</li>
<li>因此<code>fn</code>和<code>obj.fn</code>其实是一个地址</li>
</ul>
<pre><code class="lang-jsx">var fn=function(){
      this.number*=2
      number*=3
      console.log(number)
    }
</code></pre>
</li>
<li><p><code>console.log(number)</code></p>
<ul>
<li>在匿名函数自调用的时候,全局的<code>number</code>已经被修改为<code>4</code></li>
</ul>
</li>
<li><p><code>fn()</code></p>
<ul>
<li><p><code>fn</code>其实就相当于<code>window.fn</code>,此次调用<code>this</code>为<code>window</code></p>
<ul>
<li><p>因此全局的<code>number</code>被改为<code>8</code></p>
</li>
<li><p>但是<code>number*=3</code>时</p>
<ul>
<li><p>因为<code>fn</code>和<code>obj.fn</code>引用的是同一个地址的同一个函数</p>
</li>
<li><p>使用的<code>number</code>是当时因为闭包而没有被释放的<code>number</code></p>
</li>
<li>因此闭包内的<code>number</code>被改为<code>9</code></li>
<li>打印结果是<code>9</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>obj.fn()</code></p>
<ul>
<li><code>obj.fn</code>调用时,<code>this</code>为点前对象<code>obj</code></li>
<li>因此<code>obj.number</code>被修改为8</li>
<li>但是<code>number*=3</code>时<ul>
<li>使用的<code>number</code>依旧是当时因为闭包而没有被释放的<code>number</code></li>
<li>因此闭包内的<code>number</code>被改为<code>27</code></li>
<li>打印结果是<code>27</code></li>
</ul>
</li>
</ul>
</li>
<li><p>最后全局下的<code>number</code>刚才被改为<code>8</code></p>
</li>
<li><p><code>obj</code>下的<code>number</code>刚才也被修改为<code>8</code></p>
</li>
<li><p>结果<code>4 9 27 8 8</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-">多态</h5>
<ul>
<li><p><strong>同一方法</strong>在不同情况下,表现出不同的样式</p>
</li>
<li><p>比如</p>
<ul>
<li>如下实例的基类都是<code>Object</code>,但是他们的<code>toString</code>方法各不相同</li>
</ul>
<pre><code class="lang-jsx">对象.toString()             //[Object object]
数组.toString()             //会把数组降维且打散为字符串
数字.toString()             //数字字符
bool.toString()            //字符串true或者false
date.toString()            //日期字符串
</code></pre>
<ul>
<li>因此,虽然同是<code>toString</code>方法,但是在不同情况下,也表现出不同的样式</li>
<li>实际上是因为<code>Array,Number,Bool,Date</code>等如果使用 基类<code>Object</code>上的<code>toString</code>方法是不能完全满足需求的<ul>
<li>因此各自在其原型上重写了<code>toString</code>方法</li>
</ul>
</li>
</ul>
</li>
<li><p>如果子对象觉得父对象的成员不好用,可在本地定义同名自有成员,来覆盖父对象中的成员</p>
</li>
</ul>
<h5 id="foo-a">Foo.a</h5>
<pre><code class="lang-jsx">function Foo(){
  Foo.a=function(){
    console.log(1)
  }
  this.a=function(){
    console.log(2)
  }
}
Foo.prototype.a=function(){
  console.log(3)
}
Foo.a=function(){
  console.log(4)
}

Foo.a()
let obj=new Foo()
obj.a()
Foo.a()
</code></pre>
<ul>
<li><p>首先我们分析代码的执行过程</p>
<ul>
<li><p>首先函数声明提前(没什么卵用,本身就在最前面),这个函数暂时没有得到调用,里面是什么不要管</p>
</li>
<li><p><code>Foo.prototype.a=function(){...}</code></p>
<ul>
<li>其实函数也是个对象</li>
<li>因此会给<code>Foo</code>函数对象的原型对象强行赋值一个方法</li>
<li>现在全局<code>Foo</code>原型上的<code>a</code>方法是打印<code>3</code></li>
</ul>
</li>
<li><p><code>Foo.a=function(){...}</code></p>
<ul>
<li>会给<code>Foo</code>函数对象强行添加自有方法<code>a</code>,该方法为打印<code>4</code></li>
</ul>
</li>
<li><p>然后我们调用<code>Foo.a()</code></p>
<ul>
<li>根据原型链使用规则<ul>
<li>优先访问自有成员,自有成员找不到时,才去访问原型</li>
<li>自有成员有<code>a</code>这个方法,所以先会打印<code>4</code></li>
</ul>
</li>
</ul>
</li>
<li><p>然后我们把<code>Foo()</code>当成构造函数函数,创建一个其实例<code>obj</code>,同时调用<code>Foo</code></p>
<ul>
<li><p><code>Foo.a=function(){console.log(1)}</code></p>
<ul>
<li>因为函数作用域对象内找不到一个叫做<code>Foo</code>的变量,于是只能沿着作用域链去<code>winoow</code>下找全局的</li>
<li>导致全局的<code>Foo</code>(其实也就是函数本身)的<code>a</code>被篡改为打印1</li>
</ul>
</li>
<li><p>同时构造函数实例化时,<code>new</code>关键词会进行四部操作</p>
<ul>
<li><p>创建一个新的空的对象</p>
</li>
<li><p>用这个新对象调用构造函数,将构造函数中的<code>this</code>指向这个新对象,因此对这个对象中的属性进行强行赋值</p>
<ul>
<li><code>js</code>中给不存在的变量或者属性赋值,会强行创建该属性,然后强行赋值</li>
</ul>
</li>
<li><p>同时让新对象的<code>__proto__</code>指向构造函数的<code>prototype</code></p>
</li>
<li><p>将这个新对象返回,并且赋值给我们声明的<code>obj</code></p>
</li>
<li><p>因此<code>obj</code>现状</p>
<pre><code class="lang-jsx">obj:{
    a=function(){
    console.log(2)
  }
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>所以我们调用<code>obj.a()</code>时候,结果是<code>2</code></p>
</li>
<li><p>因为刚开<code>Foo()</code>函数调用时,已经把的<code>Foo.a</code>方法篡改</p>
</li>
<li><p>因此现在访问时,结果是<code>1</code></p>
</li>
<li><p>结果<code>4 2 1</code></p>
</li>
</ul>
</li>
</ul>
<h5 id="foo-x">foo.x</h5>
<pre><code class="lang-jsx">var x=0
var foo={
  x:1,
  bar:function(){
    console.log(this.x)
    var that=this
    return function(){
      console.log(this.x)
      console.log(that.x)
    }
  }
}
foo.bar()
foo.bar()()
</code></pre>
<ul>
<li>分析代码执行过程<ul>
<li>声明提前<ul>
<li>在本题意义不大,不着重考虑</li>
</ul>
</li>
<li>调用<code>foo.bar()</code><ul>
<li><code>console.log(this.x)</code>,在对象内,<code>this</code>指向本对象,结果是<code>1</code></li>
<li><code>var that=this</code>,声明了一个<code>that</code>保存了<code>this</code>指向<code>foo</code></li>
<li>返回一个<code>方法</code>,但是这个没有既变量接住,也没有执行,所以不考虑</li>
</ul>
</li>
<li>调用<code>foo.bar()()</code><ul>
<li>console.log(this.x)<code>,在对象内,</code>this<code>指向本对象,结果是`</code>1`</li>
<li><code>var that=this</code>,声明了一个<code>that</code>保存了<code>this</code>指向<code>obj</code></li>
<li>返回一个<code>方法</code>,并且调用了这个方法<ul>
<li>外层函数的作用域对象,因为被内层函数牵引着无法释放,形成闭包</li>
<li>此时<code>that</code>保存刚才的<code>this</code>指向<code>foo</code>,因此<code>that.x</code>是<code>1</code></li>
<li>而<code>return</code>出来的函数被执行,相当于函数自调用,因此<code>this</code>指向<code>window</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="queryselector-vs-getelement">querySelector vs getElement</h5>
<pre><code class="lang-jsx">&lt;div id=&#39;d1&#39; class=&#39;content&#39;&gt;&lt;/div&gt;
&lt;div id=&#39;d2&#39; class=&#39;content&#39;&gt;&lt;/div&gt;
&lt;div id=&#39;d3&#39; class=&#39;content&#39;&gt;&lt;/div&gt;

var divs=document.getElementsByClassName(&#39;content&#39;)
console.log(divs.length)    //3
d2.className=&#39;main&#39;
console.log(divs.length)   //2
</code></pre>
<ul>
<li>?<ul>
<li>因为<code>getElement</code>返回的是一个动态集合<ul>
<li>不实际存储数据</li>
<li>每次访问集合时,都会重新扫描<code>DOM</code>树</li>
<li>因为每次都不实际存储数据,所以单次查找速度快</li>
</ul>
</li>
</ul>
</li>
<li><p>querySelectorAll</p>
<ul>
<li>返回的是一个非动态集合<ul>
<li>集合中实际存储查找的所有数据,会储存起来</li>
<li>重新访问时,直接使用之前储存起来的值,不会重复查找</li>
<li>但是如果<code>DOM</code>结构发生变化,我们的 非动态集合 也无从获知</li>
<li>所以在本题目中,如果一直使用它,结果会一直是<code>3</code></li>
</ul>
</li>
</ul>
</li>
<li><p>何时使用</p>
<ul>
<li><code>getElement</code>首次查找快,但是每次都会重新查找<ul>
<li>所以查找条件简单时</li>
</ul>
</li>
<li><code>querySelectorAll</code>首次查找慢,但是后续操作方便<ul>
<li>查找条件复杂时,可以使用这个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-">包装类型</h5>
<ul>
<li><p>是什么</p>
<ul>
<li>专门封装一个原始类型的值</li>
<li>并提供对原始类型值执行操作的函数的对象</li>
</ul>
</li>
<li><p>为什么</p>
<ul>
<li>原始类型的值,只是单纯的一个值而已,没有任何的自带功能</li>
</ul>
</li>
<li><p>何时</p>
<ul>
<li>只要试图对原始类型的值调用函数或访问属性时,都会自动创建该类型的包装类型对象</li>
<li>我们访问的函数或者属性,其实都是包装类型对象提供的</li>
</ul>
</li>
<li><p>比如</p>
<pre><code class="lang-jsx">var str=&#39;hello&#39;
str.toUpperCase()
</code></pre>
<ul>
<li><p><code>str</code>本身只是一串字符,当我当我们对其调用<code>toUpperCase()</code>方法时</p>
<pre><code class="lang-jsx">//先判断 str 具体是什么类型
typeof str  //String
//于是 创建一个实例对象
str=new String(&#39;hello&#39;)
//于是就会去String的原型对象里找 toUpperCase这个方法,加以调用
str.toUpperCase()
</code></pre>
</li>
</ul>
</li>
<li><p>例题</p>
<ul>
<li><p>一串字符串<code>hello</code>,如何给其创建<code>money</code>属性,并且赋值为<code>10</code></p>
<pre><code class="lang-jsx">var str=&#39;hello&#39;
str.money=10
console.log(str.money)  //undefined
</code></pre>
<ul>
<li>上面的方法是不行的</li>
<li>需要这样</li>
</ul>
<pre><code class="lang-jsx">var str=new String(&#39;hello&#39;)
str.money=10
console.log(str)
//String {&quot;hello&quot;, money: 10}
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="promise-async-await">promise和async、await</h5>
<ul>
<li><p>比如</p>
<ul>
<li><p>服务端有三接口</p>
<pre><code class="lang-jsx">//127.0.0.1:8080/#/goods?type=a

{&quot;type&quot;:&quot;a&quot;,&quot;count&quot;:&quot;40&quot;}
</code></pre>
<pre><code class="lang-jsx">//127.0.0.1:8080/#/goods?type=b

{&quot;type&quot;:&quot;b&quot;,&quot;count&quot;:&quot;30&quot;}
</code></pre>
<pre><code class="lang-jsx">//127.0.0.1:8080/#/goods?type=c

{&quot;type&quot;:&quot;c&quot;,&quot;count&quot;:&quot;20&quot;}
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>我们想分别发送三次<code>axios</code>请求，计算三次<code>count</code>的累加值</p>
</li>
<li><p>于是</p>
<pre><code class="lang-jsx">var count=0
axios.get(&#39;127.0.0.1:8080/#/goods?type=a&#39;).then(res=&gt;{
  count+=res.count
})
axios.get(&#39;127.0.0.1:8080/#/goods?type=b&#39;).then(res=&gt;{
  count+=res.count
})
axios.get(&#39;127.0.0.1:8080/#/goods?type=c&#39;).then(res=&gt;{
  count+=res.count
})
console.log(count)  //0
</code></pre>
</li>
<li><p>结果发现 <code>count为0</code></p>
</li>
<li><p>?</p>
<ul>
<li>发送<code>ajax</code>请求是异步操作</li>
<li>会先在事件队列里等待</li>
<li>等我们同步操作执行完了,才去执行异步的</li>
<li>所以实际上<ul>
<li>请求还没发</li>
<li>就已经打印结果了</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何解决?</p>
<ul>
<li><p>让异步操作有顺序地执行?</p>
</li>
<li><p>笨方法</p>
<ul>
<li><p>回调嵌套方式</p>
<pre><code class="lang-jsx">var count=0
axios.get(&#39;127.0.0.1:8080/#/goods?type=a&#39;).then(res=&gt;{
  count+=res.count
  axios.get(&#39;127.0.0.1:8080/#/goods?type=b&#39;).then(res=&gt;{
         count+=res.count
        axios.get(&#39;127.0.0.1:8080/#/goods?type=c&#39;).then(res=&gt;{
          count+=res.count
      console.log(count) //90 
        })
  })
})
</code></pre>
<ul>
<li>回调函数原理<ul>
<li>函数执行时先去执行主函数</li>
<li>主函数执行完了,才去执行回调函数的内容</li>
<li>基于此,使得异步操作可以有序化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>嵌套层数多了,代码可读性差</li>
<li>容易造成视觉混乱</li>
</ul>
</li>
</ul>
</li>
<li><p>promise(承诺)</p>
<ul>
<li>专门解决回调地狱问题</li>
<li>既可以保证减少代码深层嵌套结构</li>
<li>又可以保证多个异步任务顺序执行</li>
</ul>
<pre><code class="lang-jsx">var total=0
function getCount(type){
  return new Promise(
    function(resolve,reject){
        axios.get(`127.0.0.1:8080/#/goods?type=${type}`).then(res=&gt;{
              resolve(res.data.count)  //相当于开门,把参数传给后面的then
            })
  })
}
//链式操作,每次都把下一步执行的方法 给return出去,方便下一个then来接住
getCount(&#39;a&#39;).then(count=&gt;{
  total+=count
  return getCount(&#39;b&#39;)
})
.then(count=&gt;{
  total+=count
  return getCount(&#39;c&#39;)
})
.then(count=&gt;{
  total+=count
     console.log(total) //90
})
</code></pre>
<ul>
<li><p>原理</p>
<ul>
<li><code>resolve()</code>调用,代码当前这步 异步操作已经完成,可以进行下一步操作<ul>
<li><code>resolve()</code>调用时还可以传参</li>
</ul>
</li>
<li>参数会被后面的<code>then(...)</code>的形参来接住</li>
<li><p><code>promise</code>函数里不能写<code>return</code></p>
</li>
<li><p>链式操作</p>
<ul>
<li>每次都把下一步操作调用并且<code>return</code>出去</li>
<li>由下一次的<code>then()</code>来接住</li>
</ul>
</li>
</ul>
</li>
<li><p>但是如上代码,其实完全没有必要这样麻烦,因为<code>a,b,c</code>并没有一个固定的顺序</p>
</li>
<li><p>只要请求的发送是在打印行为之前的就可以</p>
</li>
<li><p>所以可以简化为两步</p>
<ul>
<li>发送<code>a b c</code> 请求,但是顺序无关紧要</li>
<li>请求完成了,获取到结果了,再进行打印</li>
</ul>
<pre><code class="lang-jsx">//三个请求并行,等所有的请求都执行完,才执行总数
var total=0
function getCount(type){
  return new Promise(
    function(resolve,reject){
        axios.get(`127.0.0.1:8080/#/goods?type=${type}`).then(res=&gt;{
              total+=count  //相当于开门,把参数传给后面的then
        resolve(res.data.count)
            })
  })
}
Promise.all([
  getCount(&#39;a&#39;),
  getCount(&#39;b&#39;),
  getCount(&#39;c&#39;)
]).then(res=&gt;{
  total=result.reduce((prev,elem)=&gt;prev+elem) //res会被Primise.all每次的执行结果都放进来,是一个数组,把他们累加起来就是最终的结果90
})
</code></pre>
<ul>
<li><code>promise.all</code>数组里的操作,并没有一个必要的先后顺序</li>
<li><code>promise.all</code>数组里的都应是<code>new Promise</code>对象</li>
</ul>
</li>
</ul>
</li>
<li><p>async,await</p>
<ul>
<li><p>方法</p>
<pre><code class="lang-jsx">(async function(){
  var count=await getCount(&#39;a&#39;)
  total+=count;
  await getCount(&#39;b&#39;)
  total+=count;
  await getCount(&#39;c&#39;)
  total+=count;
})()
</code></pre>
</li>
<li><p>原理</p>
<ul>
<li>加了<code>await</code>的代码都会被挂起</li>
<li>前面的代码执行完了,才会得到执行</li>
<li>把每一个代码都加上<code>await</code>相当于变成了同步</li>
<li><code>await</code>要配合<code>new Promise()</code>来进行使用<ul>
<li>它的作用是代替的是<code>then()</code></li>
<li>但是必须要有<code>promise</code></li>
</ul>
</li>
</ul>
</li>
<li><p>实现并行</p>
<pre><code class="lang-jsx">
(async function(){
  var result=await Promise.all([
  getCount(&#39;a&#39;),
  getCount(&#39;b&#39;),
  getCount(&#39;c&#39;)
]) 
  total=result.reduce((prev,elem)=&gt;prev+elem)
})()
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="-">微信小程序的重点汇总</h5>
<ul>
<li><p>项目结构</p>
<p>| WXML | 微信小程序框架设计的一套标记语言<br />结合基础组件和事件系统，配合<code>wxss</code>绘制页面 |
| ---- | ------------------------------------------------------------ |
| WXSS | 微信小程序框架设计的一套样式文件<br />用法和<code>css</code>类似<br />但是提供了<code>rpx</code>单位,响应式像素单位 |
| js   | 小程序的逻辑文件,或者发送请求,发送云函数<br />配合<code>wxml</code>完成事件的绑定,以及数据的渲染<br />但是不能执行<code>DOM</code>操作 |
| json | 小程序设置，如页面注册，页面标题及<code>tabBar</code>                   |</p>
</li>
<li><p>原理和本质</p>
<ul>
<li>类似于<code>vue</code>,本质还是一个单页面应用<ul>
<li>所有的所谓的<code>页面</code>,其实都是组件</li>
</ul>
</li>
<li>视图层和数据层分离<ul>
<li>任何<code>ui</code>界面的变化都是基于数据的变化</li>
</ul>
</li>
</ul>
</li>
<li><p>如何使用双向绑定</p>
<ul>
<li><p>单向绑定</p>
<ul>
<li>使用<code>{{ }}</code>差值表达式给页面元素绑定数据</li>
</ul>
</li>
<li><p>双向数据绑定</p>
<ul>
<li>微信小程序不直接支持双向绑定</li>
<li>如果想要实现数据的双向绑定,需要自己手写方法<ul>
<li>双向绑定用于表单元素</li>
<li>表单内的数据变动也将同步到数据层</li>
<li>所以给表单元素创建输入事件,监控我们每次的输入行为</li>
<li>通过事件对象,获取表单内的<code>value</code>,然后通过<code>this.setData</code>反作用于数据层</li>
</ul>
</li>
</ul>
<pre><code class="lang-jsx">&lt;input  placeholder=&quot;输入关键字&quot; bindinput=&quot;change&quot;&gt;&lt;/input&gt;
change: function(e){
    this.setData({
      msg:e.detail.value,
    })
  }
</code></pre>
</li>
</ul>
</li>
<li><p>this.setData()</p>
<ul>
<li><p>是什么</p>
<ul>
<li><p>小程序提供的修改组件内<code>data</code>变量的方法</p>
</li>
<li><p>原理</p>
<ul>
<li>访问器属性的<code>set</code>方法</li>
</ul>
</li>
<li><p>注意什么</p>
<pre><code class="lang-jsx">this.setData({
  msg:&#39;2&#39;,
  msg2:&#39;23&#39;
})
</code></pre>
<ul>
<li><p>要把修改的变量写在这个对象里</p>
</li>
<li><p>如果要修改的属性名是动态拼接而成的,要在外边加<code>[ ]</code>,不能直接拼接字符串,不然会报错</p>
<pre><code class="lang-jsx">this.setData({
  [`msg${index}`]:2
})
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li><p>全局变量一般存储在<code>app.js</code>中</p>
<ul>
<li>和<code>vue</code>一样,小程序框架也是单页面应用</li>
<li><code>app.js</code>中的数据从小程序各组件都能访问的到</li>
</ul>
</li>
<li><p>如何</p>
<ul>
<li><p>定义</p>
<ul>
<li><p>在<code>app.js</code>中的<code>APP({})</code>巨大对象里创建一个<code>globalDate</code>来专门保存</p>
<pre><code class="lang-jsx">//app.js
APP({
  globalData:{
    msg:2
  }
})
</code></pre>
</li>
</ul>
</li>
<li><p>使用</p>
<pre><code class="lang-jsx">console.log(getApp().globalData.msg)
</code></pre>
</li>
<li><p>修改</p>
<pre><code class="lang-jsx">getApp().globalData.msg=3
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>调用页面绑定事件时如何传参</p>
<ul>
<li><p>不能直接在方法名后的<code>( )</code>里写 , 否则在<code>js</code>会获取不到</p>
</li>
<li><p>需要通过自定义属性<code>data-xxx</code>的方法</p>
<pre><code class="lang-jsx">&lt;view data-url=&#39;baidu.com&#39; bindtap=&#39;goSomewhere&#39;&gt;&lt;/view&gt;

taskDetail(e){
    var url = e.currentTarget.dataset.url;
    wx.navigateTo({
    url: `http://www.${url}`
  })

</code></pre>
</li>
</ul>
</li>
<li><p>小程序的路由跳转</p>
<p>| 方式                          | 是否可以跳转到tabBar | 特性                                                         |
| ----------------------------- | -------------------- | ------------------------------------------------------------ |
| wx.navigateTo( 打开新页面 )   | 否                   | 保留当前页面<br />跳转到应用的某个界面<br />路径之后可以带参数 |
| wx.redirectTo ( 页面重定向 )  | 否                   | 关闭当前页面<br />跳转到应用内的某个页面<br />可带参         |
| wx.navigateBack  ( 返回页面 ) | 否                   | 关闭当前页面<br />返回之前上一个页面<br />或者上几个页面     |
| wx.switchTab ( tabBar跳转 )   | 是                   | 只能跳转到<code>tabBar</code>页面<br />不能跳转到其他页面<br />调用时会关闭所有非<code>tabBar</code>页面<br />之后进行切换,不可带参数 |
| wx.reLaunch ( 重启 )          | 是                   | 关闭所有页面<br />然后跳转到指定页面<br />是否为<code>tabBar</code>页面皆可,<br />但是如果是<code>tabBar</code>的话,不能携带参数 |</p>
</li>
<li><p>小程序的生命周期</p>
<ul>
<li>是整个小程序的生命周期,而不是单个页面的</li>
</ul>
</li>
<li><p>写在<code>app.js</code>中</p>
<p>| 声明周期 |                             特性                             |
| -------- | :----------------------------------------------------------: |
| onLaunch |      用户首次打开小程序，会触发onLauch(全局只触发一次);      |
| onShow   | 小程序初始化完成后，触发onShow方法，监听小程序显示；<br />小程序从后台进入前台显示，触发onShow方法 |
| onHide   |            小程序从前台进入后台，触发onHide方法；            |
| onError  |     小程序后台运行一定时间，或系统资源占用过高，会被销毁     |</p>
</li>
</ul>
<ul>
<li><p>页面的生命周期</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="img"></p>
<p>| 周期              |                    特性                     |
| ----------------- | :-----------------------------------------: |
| onLoad            |   用户首次打开小程序时触发,全局只触发一次   |
| onReady           |             页面初次渲染时触发              |
| onShow            | 页面显示时触发,或者是页面从后台切换到前台时 |
| onHide            |          页面从前台切往后台时触发           |
| onUnload          |               页面卸载时触发                |
| onPullDownRefresh |           用户触发下拉事件时调用            |
| onReachBottom     |         用户触发上拉触底事件时调用          |</p>
</li>
</ul>
<ul>
<li><p>如何实现下拉刷新</p>
<ul>
<li>首先在全局 <code>config</code> 中的 <code>window</code> 配置 <code>enablePullDownRefresh</code></li>
<li>在 <code>Page</code> 中定义 <code>onPullDownRefresh</code> 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法</li>
<li>请求返回后，调用 <code>wx.stopPullDownRefresh</code> 停止下拉刷新</li>
</ul>
</li>
<li><p>bindtap和catchtap的区别是什么</p>
<ul>
<li>相同点：<ul>
<li>首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</li>
</ul>
</li>
<li>不同点：<ul>
<li>他们的不同点主要是<code>bindtap</code>是不会阻止冒泡事件的，<code>catchtap</code>是阻值冒泡的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-api3-0-">百度地图API3.0最基本的调用</h5>
<ul>
<li><p>首要准备</p>
<ul>
<li>申请百度地图开发者密钥</li>
</ul>
</li>
<li><p>初步配置百度地图</p>
<ul>
<li>页面上注册一个<code>#container</code>来保存咱们的地图</li>
<li>注意要给<code>body</code>,以及地图容器一个高</li>
</ul>
<pre><code class="lang-html">&lt;head&gt;  
    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;  
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;  
    &lt;title&gt;Baidu Map &lt;/title&gt;  
    &lt;style type=&quot;text/css&quot;&gt;  
        html{height:100%}  

        body{height:100%;
              margin:0px;
              padding:0px}  

        #container{
                    height:100%
          }  
    &lt;/style&gt;  
&lt;/head&gt;  
&lt;body&gt;
  &lt;div id=&#39;container&#39;&gt;&lt;/div&gt;
&lt;/body&gt;  
</code></pre>
<ul>
<li><p>引入百度地图<code>js</code>文件</p>
<pre><code class="lang-jsx">&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=3.0&amp;ak=您的密钥&quot;&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>注意密钥就是刚才我们申请的密钥</li>
</ul>
</li>
<li><p>初始化地图逻辑</p>
<pre><code class="lang-jsx">var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例  
var point = new BMap.Point(116.404, 39.915);  // 创建点坐标  
map.centerAndZoom(point, 15);                 // 初始化地图，设置中心点坐标和地图级别  
</code></pre>
</li>
<li><p>是否开启滚轮缩放</p>
<pre><code class="lang-jsx">map.enableScrollWheelZoom(true);     //开启鼠标滚轮缩放
</code></pre>
</li>
<li><p>至此我们初步配置了一个带有缩放功能的百度地图</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1585704436841.png" alt="1585704436841"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>地图控件</p>
<p>| <strong>控件</strong>     | 命令                                                         | <strong>简介</strong>                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象基类     | Control                                                      | 所有控件均继承此类的方法、属性。通过此类您可实现自定义控件   |
| 平移缩放控件 | map.addControl(new BMap.NavigationControl())                 | PC端默认位于地图左上方，它包含控制地图的平移和缩放的功能。移动端提供缩放控件，默认位于地图右下方 |
| 缩略地图     | map.addControl(new BMap.OverviewMapControl());               | 默认位于地图右下方，是一个可折叠的缩略地图                   |
| 比例尺       | map.addControl(new BMap.ScaleControl());                     | 默认位于地图左下方，显示地图的比例关系                       |
| 地图类型     | map.addControl(newBMap.MapTypeControl());<br/>map.setCurrentCity(&quot;北京&quot;); | 默认位于地图右上方                                           |
| 定位         | GeolocationControl                                           | 针对移动端开发，默认位于地图左下方                           |</p>
<ul>
<li>控件的添加基于需求</li>
</ul>
</li>
</ul>
<ul>
<li><p>本地搜索功能</p>
<pre><code class="lang-jsx">var local = new BMap.LocalSearch(map, {      
        renderOptions:{map: map}      
});      
//本地搜索
local.search(&quot;肯德基&quot;);
//周边搜索
local.searchNearby(&quot;小吃&quot;, &quot;前门&quot;);
</code></pre>
</li>
<li><p>获取当前位置</p>
<pre><code class="lang-jsx">var geolocation = new BMap.Geolocation();
        geolocation.getCurrentPosition(function(r){
           if(this.getStatus() == BMAP_STATUS_SUCCESS){
               var mk = new BMap.Marker(r.point);
               map.addOverlay(mk);
               map.panTo(r.point);
               alert(&#39;您的位置：&#39;+r.point.lng+&#39;,&#39;+r.point.lat);
           }else{
               alert(&#39;failed&#39;+this.getStatus());
           }},{enableHighAccuracy: true})
</code></pre>
</li>
<li><p>百度地图<code>API</code>功能十分复杂,其他功能详见官方文档</p>
</li>
</ul>
<h5 id="vue-query-params-">vue中query传值和params传值的区别</h5>
<ul>
<li><p>首先呢 , 这两者的作用都是在我们使用<code>this.$router.push( )</code>时顺便传参</p>
<ul>
<li><code>this.$router.push( )</code>传值既可以是字符串,也可以是对象</li>
</ul>
<pre><code class="lang-jsx">// 字符串
this.$router.push(&#39;/home/first&#39;)
// 对象
this.$router.push({ path: &#39;/home/first&#39; })
// 命名的路由
this.$router.push({ name: &#39;home&#39;, params: { userId: wise }})
</code></pre>
</li>
<li><p><code>params</code>只能用<code>name</code>(路由名称)来引入路由，<code>query</code>用<code>path</code>(路径)来引入</p>
</li>
<li><p><code>params</code>类似于<code>post</code>，<code>query</code>更加类似于我们<code>ajax</code>中<code>get</code>传参</p>
</li>
<li><p>说的再简单一点，前者在浏览器地址栏中不显示参数，后者显示，所以<code>params</code>传值相对安全一些。</p>
</li>
<li><p><code>params</code>传值一刷新就没了，<code>query</code>传值刷新还存在</p>
</li>
</ul>
<h5 id="-">普通函数和箭头函数</h5>
<ul>
<li><p>首先分析箭头函数</p>
<ul>
<li><p>相比于普通函数更加简洁</p>
<ul>
<li>省略<code>function()</code>关键词,用<code>()=&gt;</code>代替</li>
<li>如果有且只有一个参数,小括号可以不写</li>
<li>如果函数体只有一行代码,大括号可以不写</li>
<li>如果这一行代码还是<code>return</code>出来的 , 省略<code>return</code></li>
</ul>
</li>
<li><p>箭头函数没有自己的<code>this</code>指向</p>
<ul>
<li>箭头函数中的<code>this</code>和其上下文对象指向一致<ul>
<li>也可以说箭头函数<code>this</code>内外指向一致</li>
</ul>
</li>
<li>因为没有自己的<code>this</code>指向,所以即便使用<code>call apply bind</code>等也无法修改</li>
</ul>
</li>
<li><p>箭头函数没有<code>arguments</code>类数组对象</p>
<ul>
<li><p>以往为了函数重用 , 有时候我们不确定函数到底要定义多少个形参</p>
<ul>
<li>于是形参那里直接不写</li>
<li>然后在函数体内通过<code>arguments</code>类数组对象来获取咱们的传入所有参数</li>
</ul>
</li>
<li><p>但是箭头函数不能这样</p>
</li>
<li><p>可以使用展开运算符<code>...arg</code>来代替</p>
<pre><code class="lang-jsx">var fn=(...arg)=&gt;{
    console.log(arg)  //[1,2,3]
}
fn(1,2,3)
</code></pre>
<ul>
<li><code>arg</code>会把咱们传进去的所有参数,装进一个数组里,方便操作</li>
</ul>
</li>
</ul>
</li>
<li><p>箭头函数不能作为构造函数</p>
<ul>
<li>因为没有自己的<code>this</code>指向<ul>
<li>实例化对象<code>new</code>其实就是创建一个新对象,然后把构造函数的<code>this</code>指向这个新对象强行赋值的过程</li>
<li>但是箭头函数没有自己的<code>this</code></li>
<li>因此不能</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>普通函数的<code>this</code></p>
<ul>
<li><p>一般指向函数调用者,也就是点前的对象</p>
<ul>
<li><code>obj.fn( )</code>那么<code>this</code>就指向<code>obj</code></li>
<li>直接<code>fn()</code>,就指向<code>window</code></li>
</ul>
</li>
<li><p>自执行函数<code>this</code>指向<code>window</code></p>
</li>
<li><p><code>return</code>出来的函数被执行也指向<code>window</code></p>
<pre><code class="lang-jsx">var obj={
  fn(){
    return function(){
      console.log(this)
    }
  }
}
obj.fn()()
</code></pre>
<ul>
<li>以这个为例</li>
<li><code>obj.fn()</code>这个函数被执行得到的结果是<code>function(){console.log(this)}</code></li>
<li>因此<code>obj.fn()()</code>,其实就相当于<code>function(){console.log(this)}()</code><ul>
<li>类似于自调用函数</li>
<li>所以指向<code>window</code></li>
</ul>
</li>
</ul>
</li>
<li><p>如果这个函数是通过<code>DOM</code>元素触发事件而执行的,<code>this</code>指向那个<code>DOM</code>元素</p>
</li>
<li><p>定时器里的<code>this</code>默认指向<code>window</code></p>
</li>
<li><p>可以使用<code>call apply bind</code>等修改<code>this</code></p>
<ul>
<li><code>call apply</code>是修改本次<code>this</code>并且立刻调用函数</li>
<li><code>bind</code>是永久替换<code>this</code>,但是暂不调用函数</li>
</ul>
</li>
<li><p>可以在函数外声明一个<code>that=this</code>来保存函数外的<code>this</code>指向</p>
</li>
</ul>
</li>
</ul>
<h5 id="vue-react-">vue和React区别</h5>
<ul>
<li>Vue 使用的是template+JavaScript+CSS的组合模式呈现</li>
<li>React 的特色在于函数式编程<ul>
<li><code>jsx</code>写法编组件</li>
<li><code>vue</code>的<code>v-if v-for</code>等在<code>react</code>中使用<code>js代码</code>配合<code>jsx</code>也可以轻易实现</li>
</ul>
</li>
<li>vue自带数据绑定,MVVM涉及模式<ul>
<li>强掉数据的可变性</li>
</ul>
</li>
<li>react需要手写数据绑定逻辑</li>
<li>本质都是用<code>js</code>操作组件</li>
</ul>
<h5 id="-vs-">单页面应用 vs 多页面应用</h5>
<table>
<thead>
<tr>
<th></th>
<th>单页面应用</th>
<th>多页面应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>组成</td>
<td>只有唯一完整的<code>html</code>文件<br />每个所谓的<code>页面</code>,其实都是组件<br />切换<code>页面</code>其实就是<br />拿走之前的组件,换成其他组件</td>
<td>每个<code>页面</code>都是真实而完整的<code>html</code>文件</td>
</tr>
<tr>
<td>公共资源</td>
<td>资源公用<br />实质上只在唯一完整的<code>html</code>中引用一次</td>
<td>每个<code>页面</code>都需要加载一次,页面间不共用</td>
</tr>
<tr>
<td>url模式</td>
<td>abc.com/#/index</td>
<td>abc.com/index.html</td>
</tr>
<tr>
<td>用户体验</td>
<td>页面间切换快,用户体验良好<br />虽然首屏加载速度较慢,<br />但是可以使用路由懒加载等方式进行优化</td>
<td>页面切换加载缓慢，流畅度不够，用户体验比较差</td>
</tr>
<tr>
<td>动画</td>
<td>因为都在一个页面里,所以可以实现</td>
<td>实现不能</td>
</tr>
<tr>
<td>数据传递</td>
<td>组件传值<br />vuex<br />cookie session localStroage<br />url</td>
<td>cookie , session, localStroage<br />url</td>
</tr>
<tr>
<td>搜索引擎优化</td>
<td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td>
<td>简单</td>
</tr>
<tr>
<td>适用范围</td>
<td>高要求的体验度、追求界面流畅的应用</td>
<td>适用于追求高度支持搜索引擎的应用</td>
</tr>
</tbody>
</table>
<h5 id="vue-">Vue组件之间传值</h5>
<ul>
<li><p>父传给子</p>
<ul>
<li><p>方法</p>
<ul>
<li>在父组件上给所引用的子组件定义一个 <strong>自定义属性</strong></li>
<li>把想要传的值绑在这个自定义属性上</li>
<li>在子组件中的<code>props</code>中,加入这个自定义属性名</li>
<li>此时父组件穿件来的变量就会称为子组件的自有变量</li>
<li>和使用<code>data</code>里面的数据一样访问这个变量</li>
</ul>
<pre><code class="lang-jsx">//在父组件里
&lt;template&gt;
  &lt;child :自定义属性名=&#39;msg&#39;&gt;&lt;/child&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
 data(){
   return {
     msg:&#39;123&#39;
   }
 }    
}
&lt;/script&gt;
</code></pre>
<pre><code class="lang-jsx">//在子组件里
&lt;template&gt;
  &lt;div&gt;{{自定义属性名}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
 props:{
   //props也可以写成数组,把每个属性名当成字符串写进来就好
   //但是如果写成数组了,就不能写类型了
   自定义属性名:String //类型也可以写其他
 }   
}
&lt;/script&gt;
</code></pre>
<ul>
<li>注意<ul>
<li>如果传的值是 <strong>原始类型</strong> 的话,按值传递 , 子组件里无论对其进行怎样的操作都不会影响到父组件</li>
<li>但是如果传的是 <strong>引用类型</strong> 的话,传过来的是地址 <ul>
<li>因此无论父组件还是子组件的这个值变了</li>
<li>都会牵连对方</li>
</ul>
</li>
</ul>
</li>
<li>原理<ul>
<li><code>vue</code>在每次加载一个组件时,都会扫描组件元素标签上是否存在自定义属性<ul>
<li>也就是非原生<code>HTML</code>属性</li>
<li>也不是<code>vue</code>自己十几个属性</li>
</ul>
</li>
<li>如果发现确实有 , 就回去对自己的<code>props</code>对象或者数组进行遍历<ul>
<li>找是否有和这个自定义属性同名的内容</li>
</ul>
</li>
<li>如果有,就让其称为子组件的自有属性</li>
<li>并且把父组件里这个自定义属性对应的数据赋值过来</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>子传给父</p>
<ul>
<li><p>通过给子组件绑定事件的方式</p>
</li>
<li><p>事件触发时, 通过 使用<code>this.$emit(&#39;父组件方法名&#39;,传递的参数)</code>给父组件传值</p>
<ul>
<li>当父组件相应的方法调用时 </li>
<li>会通过形参获取子组件传过来的参数</li>
</ul>
<pre><code class="lang-jsx">//子组件里
&lt;template&gt;
    &lt;div&gt;
    &lt;button @click=&#39;setData&#39;&gt;向父组件传参&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
 data(){
   return{
     msg:2
   }
 },
 methods:{
   setData(){
     //这样的话,当父组件的toFather方法调时,就能获取到子组件的msg参数
     this.$emit(&#39;toFather&#39;,this.msg)
   }
 }
}
&lt;/script&gt;
</code></pre>
<pre><code class="lang-jsx">//父组件里
&lt;script&gt;
export default{
 data(){
   return{
     sonMsg:&#39;&#39;
   }
 },
 created(){
   toFather(data){
     //当父组件的相应方法调用时,就会通过形参获取到子组件里传来的数据
     console.log(data)
     this.sonMsg=data
   }
 }
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>兄弟组件之间</p>
<ul>
<li><p>如何</p>
<ul>
<li><p>借助中央事件总线 , 两组件外部建立一个<code>Bus.js</code>文件,将自己<code>export</code></p>
<pre><code class="lang-jsx">import Vue from &#39;Vue&#39;
export default new Vue
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* 两兄弟组件被同一父组件引用着

* 给`组件1` 绑定事件

* 通过`Bus.$emit`传递过去一个方法名和参数

  ```jsx
  //组件1
  &lt;template&gt;
      &lt;button @click=&#39;sendMsg&#39;&gt;&lt;/button&gt;
  &lt;/template&gt;

  &lt;script&gt;
  export default{
      methods:{
      sendMsg(){
        Bus.$emit(&#39;send&#39;,2)
      }
    }    
  }
  &lt;/script&gt;
  ```

* 在兄弟组件那里使用`Bus.$on`来进行接收

  ```jsx
  //组件2
  &lt;script&gt;
  export default{
      created(){
      Bus.$On(&#39;send&#39;,function(val){
        console.log(&#39;从兄弟组件那里拿来的参数是&#39;+val)
      })
    }
  }
  &lt;/script&gt;
  ```
</code></pre><h5 id="vue-">Vue路由懒加载</h5>
<ul>
<li><p>什么是</p>
<ul>
<li>懒加载就是只去加载用户可能访问的到的 <strong>资源</strong><ul>
<li>提高的页面加载速度</li>
<li>节省用户流量</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么</p>
<ul>
<li>Vue<ul>
<li>单页面应用 , 所有的 <strong>页面</strong> 都不过是一个 <strong>组件</strong></li>
<li><code>webpack</code>进行打包时,会把咱们所有的<code>vue</code>组件,打包成巨大的<code>js</code>文件</li>
<li>导致首屏加载很慢<ul>
<li>但是很多时候,这种行为是没有必要的</li>
<li>因为很多页面,用户可能根本不会去访问,因此根本就没有加载的必要</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何</p>
<ul>
<li><p>方法一</p>
<ul>
<li><p>在引用路由时,先不要进行<code>import</code>进行引入</p>
</li>
<li><p>然后在相对应 <strong>路由字典</strong> 里的<code>component</code>里用<code>require</code>代替<code>import</code></p>
<pre><code class="lang-jsx">// import HelloWorld from &#39;@/components/HelloWorld&#39;  这步就不写了
routes: [
        {
          path: &#39;/&#39;,
          name: &#39;HelloWorld&#39;,
          component: resolve =&gt; require([&#39;@/components/HelloWorld&#39;], resolve)
        }
]
</code></pre>
</li>
</ul>
</li>
<li><p>方法二</p>
<ul>
<li><p>其实和上面的原理类似</p>
</li>
<li><p>不要先<code>import</code></p>
<pre><code class="lang-jsx">// import HelloWorld from &#39;@/components/HelloWorld&#39;  这步就不写了
routes: [
        {
          path: &#39;/&#39;,
          name: &#39;HelloWorld&#39;,
          component: () =&gt; import(&#39;@/components/HelloWorld.vue&#39;)
        }
]
</code></pre>
</li>
</ul>
</li>
<li><p><code>ChunkName</code>注释法( <code>Vue</code>和<code>Webpack</code>官方推荐 )</p>
<ul>
<li><p>这种方法 , 同样先不要进行<code>import</code></p>
</li>
<li><p>先在<code>webpack.base.config.js</code>中配置 <code>ChunkFileName</code></p>
<pre><code class="lang-jsx">output: {
path: config.build.assetsRoot,
filename: &#39;[name].js&#39;,
chunkFilename: &#39;[name].js&#39;,
publicPath: process.env.NODE_ENV === &#39;production&#39;
  ? config.build.assetsPublicPath
  : config.dev.assetsPublicPath
},
</code></pre>
</li>
<li><p>然后在需要进行懒加载的路由字典里这么写</p>
<pre><code class="lang-jsx">{
  path: &#39;/home/user&#39;,
  name: &#39;user&#39;,
  component: () =&amp;gt; import(/* webpackChunkName:&quot;user&quot;*/ &#39;../view/User.vue&#39;)
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="vue-keepalive">Vue keepAlive</h5>
<ul>
<li><p>是什么</p>
<ul>
<li>用于缓存之前加载的组件</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>组件切换时 让其保持之前的加载状态</li>
<li>避免反复渲染影响性能</li>
<li>同时减少请求次数,缓解服务器压力</li>
</ul>
</li>
<li><p>如何 ?</p>
<ul>
<li><p>在需要 <code>keepAlive</code> 进行缓存的 路由字典里进行配置</p>
<ul>
<li>为其添加<code>mata</code>属性( 不可改名 )</li>
<li>在<code>meta</code>中给<code>keepAlive</code>配置为<code>true</code></li>
</ul>
<pre><code class="lang-jsx">{
  path:&#39;/index&#39;,
  name:&#39;index&#39;,
  component:Index,
  meta:{
    keepAlive:true
  }
}
</code></pre>
</li>
<li><p>在<code>app.vue中</code>的<code>templa</code>里</p>
<pre><code class="lang-jsx">&lt;keep-alive&gt;
    &lt;router-view v-if=&#39;$route.meta.keepAlive&#39;/&gt;
&lt;/keep-alive&gt;
&lt;router-view v-if=&#39;!$route.meta.keepAlive&#39;/&gt;    
</code></pre>
<ul>
<li>包在<code>keep-alive</code>标签里的内容是使用缓存的<ul>
<li><code>v-if</code>会进行判断,如果这个路由的<code>keepAlive</code>是<code>true</code>的话就使用缓存</li>
</ul>
</li>
<li>不然的话,就使用不带缓存的普通<code>router-view</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-">路由守卫</h5>
<ul>
<li><p>是什么</p>
<ul>
<li>我们之前每个<code>vue</code>组件都有四组生命周期<strong>钩子函数</strong>,分别在组件<code>创建</code>,<code>挂载</code>,<code>更新</code>以及<code>销毁</code>的时候触发</li>
<li>路由守卫其实是关于路由的一组<strong>钩子函数</strong></li>
<li>实现在 <strong>进入 / 离开</strong> 一个路由时,进行的操作</li>
</ul>
</li>
<li><p>有什么作用</p>
<ul>
<li><p>有时候 , 我们需要对用户的跳转行为进行一些限制</p>
<ul>
<li>比如说<ul>
<li>我们希望用户只能在登录状态下才能 跳转到购物车</li>
<li>通过直接输入<code>url</code>或者其他手段想要进入商品购物车页的,就应该给予拦截,阻止页面进行跳转</li>
</ul>
</li>
</ul>
</li>
<li><p>有些时候 , <code>keepAlive</code>是不能写死的,要根据用户的实际操作而动态变化</p>
<ul>
<li>比如说 , 在一个商城项目里<ul>
<li>我们每次从首页跳转到商品列表页的时候</li>
<li>假如我第一次是通过<code>手机</code>关键子进入的商品列表页</li>
<li>但是以后访问的可能不是<code>手机</code>了,那就没必要对商品列表页的内容进行缓存</li>
</ul>
</li>
<li>但是,如果是从详情页跳转到商品页就不同了<ul>
<li>因为我们之所以进入了详情页</li>
<li>肯定是之前已经在商品页选好了商品</li>
<li>这时候我们进行再进行后退 , 就应该回退到之前选的 那类商品那里</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>如何使用( 组件路由守卫 )</p>
<ul>
<li><p>就一个组件而言,使用最多的路由钩子函数是<code>beforeRouteLeave</code> 和<code>beforeRouteEnter</code></p>
</li>
<li><p>路由守卫钩子函数有三个参数</p>
<ul>
<li>to<ul>
<li>表示你要去哪</li>
</ul>
</li>
<li>from<ul>
<li>表示你从哪里来</li>
</ul>
</li>
<li>next<ul>
<li><code>next()</code><ul>
<li>直接往下执行,不进行干预</li>
<li>如果不阻止或者修改之前的路由跳转行为,这个<code>next( )</code>必须写</li>
</ul>
</li>
<li><code>next(false)</code><ul>
<li>中断当前导航</li>
</ul>
</li>
<li><code>next(&#39;/&#39;)</code>/<code>next( { path : &#39;/&#39; } )</code><ul>
<li>跳转到其他地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>比如实现刚才的需求</p>
<pre><code class="lang-jsx">//home.vue
beforeRouteLeave(to,from,next){
  console.log(&#39;路由离开home页&#39;);
  if(to.name==&#39;products&#39;){
    //如果是从首页跳到商品页,不缓存
    to.meta.keepAlive=false
  }
  next()
}
</code></pre>
<ul>
<li>当路由即将离开首页时触发</li>
<li>判定我们是否要去商品页</li>
<li>确实是要去商品页</li>
<li>经过我们刚才的分析,不应该缓存</li>
<li>于是把<code>to</code>(即我们要去的商品页)的<code>keepAlive</code>改为<code>fasle</code>,让它不再进行缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>如何使用( 全局路由守卫 )</p>
<ul>
<li><p>实际上,完整的路由守卫钩子函数是这样的</p>
<p>| 导航被触发                                                   |
| ------------------------------------------------------------ |
| 在<code>失活</code>的组件里调用离开守卫<code>beforeRouteLeave</code>               |
| 调用全局的<code>beforeEach</code>守卫                                   |
| 在重用的组件里调用<code>beforeRouteUpdate守卫(2.2+)</code>              |
| 在路由配置里调用<code>beforeEnter</code>                                |
| 解析异步路由组件                                             |
| 在被激活的组件里调用<code>beforeRouterEnter</code>                      |
| 调用全局的<code>beforeResolve守卫(2.5+)</code>                          |
| 导航被确认                                                   |
| 调用全局的<code>afterEach</code>钩子                                    |
| 触发<code>DOM</code>更新                                                |
| 用创建好的实例调用<code>beforeRouteEnter</code>守卫中传给<code>next</code>的回调函数 |</p>
</li>
<li><p>根据这个流程,我们可以发现,每次我们进行路由跳转的时候,全局的<strong>路由钩子函数</strong>都会被触发</p>
</li>
<li><p>全局的路由钩子函数也有两个比较重要</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>假如一个需求,用户从任何界面跳往购物车时候,都会进行验证</p>
<ul>
<li>查看用户是否登录</li>
<li>如果用户没有登录</li>
<li>就阻止用户跳转 ,并自动将路由切换到登录页面</li>
</ul>
<pre><code class="lang-jsx">router.beforeEach((to, from, next) =&gt; {
  console.log(to)
  if(to.name==&#39;cart&#39;){
    //如果vuex中没有保存用户登录的数据,证明用户没有登录
    this.$store.state.uid?next():next({path:&#39;/login&#39;})
  }
}
</code></pre>
</li>
</ul>
<h5 id="webpack-4-x-">webpack 4.X 打包机制基本</h5>
<ul>
<li><p>是什么</p>
<ul>
<li>前端资源 <strong>加载/打包</strong> 工具</li>
<li>静态分析<code>js</code>之间存在怎么样的关系</li>
<li>最终合并成生产环境需要的代码</li>
</ul>
</li>
<li><p>前提</p>
<ul>
<li><p>全局安装</p>
<ul>
<li><code>webpack4</code>需要<code>NodeJS V9</code>以上</li>
<li><code>npm i webpack webpack-cli -g</code></li>
</ul>
</li>
<li><p>局部安装</p>
<pre><code class="lang-jsx">npm i webpack webpack-cli -S
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>基本使用</p>
<ul>
<li><p>生成<code>package.json</code></p>
<pre><code class="lang-jsx">npm init
</code></pre>
</li>
<li><p>打包</p>
<ul>
<li>默认入口文件 <code>src / index.js</code></li>
<li>默认出口文件<code>dist / main.js</code></li>
</ul>
<pre><code class="lang-jsx">//默认情况下是生产环境 也就是一行代码 可读性极差的的模式
webpack 输入文件.js -o 输出文件.js
</code></pre>
<pre><code class="lang-jsx">webpack --mode development 输入文件.js -o 输出文件.js
</code></pre>
</li>
<li><p>如果只写<code>webpack</code>或者<code>webpack --mode development</code> </p>
<ul>
<li>会将入口文件以及其依赖的文件</li>
<li>打包到<code>dist</code>文件夹下</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>配置</p>
<ul>
<li><p>为什么</p>
<ul>
<li><code>webpack</code>本身是打包<code>js</code>文件的</li>
<li>如果想要打包其他文件,必须进行相关配置</li>
</ul>
</li>
<li><p>如何</p>
<ul>
<li><p>在当前目录下新建一个<code>webpack.config.js</code></p>
</li>
<li><p><code>npm init</code></p>
</li>
<li><p>先在<code>webpack.config.js</code>中配置<strong>入口和出口</strong>文件</p>
<pre><code class="lang-jsx">const path=require(&#39;path&#39;)
module.exports={
  //入口
    entry:&#39;./src/index.js&#39;  //入口文件可以自行修改,
  //出口
  output:{
  //最后会打包成dist文件夹的一个build.js
   path:path.resolve(_dirname,&#39;dist&#39;),
   filename:&#39;build.js&#39;
    }
}
</code></pre>
</li>
</ul>
</li>
<li><p>loader</p>
<ul>
<li>能让<code>webpack</code>打包其他非<code>js</code>文件</li>
</ul>
</li>
<li><p>plugins</p>
<ul>
<li>有效地打包或者压缩文件</li>
</ul>
</li>
</ul>
</li>
<li><p>dev-server ( 本地服务 )</p>
<ul>
<li><p>安装</p>
<pre><code class="lang-jsx">npm i webpack-dev-server -S
</code></pre>
</li>
<li><p>配置</p>
<pre><code class="lang-jsx">//webpack.config.js中
const path=require(&#39;path&#39;)
module.exports={
  //入口
    entry:&#39;./src/index.js&#39;  //入口文件可以自行修改,
  //出口
  output:{
  //最后会打包成dist文件夹的一个build.js
   path:path.resolve(_dirname,&#39;dist&#39;),
   filename:&#39;build.js&#39;
    },
  devServe:{
    contentBase:&#39;./src&#39;, //配置路径
    port:&#39;8080&#39;,  //配置端口号
    inline:true //实时刷新
  }
}
</code></pre>
<pre><code class="lang-jsx">//package.json中scripts里
&quot;dev&quot;:&quot;webpack-dev-serve --open --inline&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>loader ( 加载程序 )</p>
<ul>
<li><p>不同文件的<code>loader</code></p>
<p>| 扩展名                    | 语义                                                | loader举例                                                   |
| ------------------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| .js                       | returns module exports                              | babel-loader                                                 |
| .ts                       | returns module exports                              | ts-loader                                                    |
| .coffee                   | returns module exports                              | coffee-loader coffee-redux-loader                            |
| .jsx                      | returns module exports (react component)            | jsx-loader react-hot-loader!jsx-loader                       |
| .json .json5              | returns json value                                  | json-loader json5-loader                                     |
| .txt                      | return string value                                 | raw-loader                                                   |
| .css                      | returns nothing, side effect of adding style to DOM | style-loader!css-loader style-loader!css-loader!autoprefixer-loader |
| .less                     | returns nothing, side effect of adding style to DOM | style-loader!css-loader!less-loader                          |
| .scss                     | returns nothing, side effect of adding style to DOM | style-loader!css-loader!scss-loader                          |
| .styl                     | returns nothing, side effect of adding style to DOM | style-loader!css-loader!stylus-loader                        |
| .png .jpg .jpeg .gif .svg | returns url to image                                | file-loader url-loader                                       |
| .woff .ttf                | returns url to font                                 | file-loader url-loader                                       |
| .wav .mp3                 | returns url to audio                                | file-loader url-loader                                       |
| .mpeg .mp4 .webm .ogv     | returns url to video                                | file-loader                                                  |
| .html                     | returns HTML as string                              | html-loader                                                  |
| .md .markdown             | returns HTML as string                              | html-loader!markdown-loader                                  |
| .jade                     | returns template function                           | jade-loader                                                  |
| .hbs .handlebars          | returns template function                           | handlebars-loader                                            |</p>
</li>
<li><p>以<code>css</code>为例</p>
<ul>
<li><p>需要先</p>
<pre><code class="lang-jsx">npm install style-loader css-loader -S
</code></pre>
</li>
<li><p>如何配置</p>
<pre><code class="lang-jsx">//在 webpack.config.js中配置
module:{
  rules:[
    {
      test:/\.css$/,  //以.css结尾
      use:[&#39;css-loader&#39;,&#39;style-loader&#39;]
    },
    {
      test:/\.(jpg|jpeg|gif|png)$/,  //以.css结尾
      use:[&#39;file.loader&#39;]
    }
  ]
}
</code></pre>
<ul>
<li>假如引用了<code>background-image</code>还需要配置图片<code>loader</code>,过程同<code>css</code>一样</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>plugins</p>
<ul>
<li><p><code>html-webpack-plugin</code>插件</p>
</li>
<li><p>使用</p>
<ul>
<li><p>安装</p>
<pre><code class="lang-jsx">npm i html-webpack-plugin -S
</code></pre>
</li>
<li><p>配置</p>
<pre><code class="lang-jsx">//webpack.config.js
const HtmlWebpackPlugin=require(&#39;html-webpack-plugin&#39;)

...
module.exports={
  ...
  plugins:[
    //会自动去找
    new HtmlWebpackPlugin({
      template:&#39;./src/index.html&#39;,
      //默认是html , 也可以自动为其命名
      fileName:&#39;a.html&#39;,
      minify:{
        removeAttributeQuotes:true,//去除引号
        removeComments:true, //去除注释
        removeEmptyAttributes:true,//去除空属性
        collaspseWhitesapace:true//去除空格回车
      }
    })
  ]
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="vuex">Vuex</h5>
<ul>
<li><p>回顾 : 组件间数据共享</p>
<ul>
<li>父=&gt;子<ul>
<li>自定义属性</li>
</ul>
</li>
<li>子=&gt;父<ul>
<li>$emit</li>
</ul>
</li>
<li>兄弟间<ul>
<li>EventBus</li>
</ul>
</li>
</ul>
</li>
<li><p>Vuex是什么</p>
<ul>
<li><p><code>Vuex</code> 是一个实现组件全局状态(<code>数据</code>)管理的一种机制,可以方便的管理组件之间数据的共享</p>
</li>
<li><p>它采用<code>集中式存储</code>管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p>
</li>
<li><p>关系复杂之间的组件传参,可能会很麻烦</p>
<ul>
<li><p>比如两个组件不是同属一个父组件的情况,数据想要实现共享,需要传来传去,很麻烦!</p>
</li>
<li><p>但是如果使用<code>Vuex</code>就比较容易实现,<code>Vuex</code>适合这种<strong>大范围 复杂或者比较频繁的数据共享</strong></p>
</li>
<li><p>如下图</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1584491434588.png" alt="1584491434588"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>Vuex</code>的优点</p>
<ul>
<li>共享<strong>数据集中</strong>管理,易于开发和维护</li>
<li>高效地实现组件之间的数据共享,<strong>提高开发效率</strong></li>
<li>存储在<code>Vuex</code>里的数据是<strong>响应式的</strong>,能够实时保持<strong>数据和页面的同步</strong></li>
</ul>
</li>
<li><p>什么数据适合存储在<code>Vuex</code>中</p>
<ul>
<li>组件中共享的数据,一般才有必要存在<code>vuex</code>中,对于组件的私有数据,依旧存在组件的自身的<code>data</code>里即可</li>
</ul>
</li>
<li><p>安装和配置</p>
<ul>
<li>安装<code>vuex依赖包</code></li>
</ul>
<pre><code class="lang-cmd">npm install vuex --save
</code></pre>
<ul>
<li>创建<code>store.js</code><ul>
<li>引入<code>vuex</code></li>
<li>创建<code>vuex实例</code>,并且<strong>暴露</strong>出去</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript">import Vue from &#39;vue&#39;
import Vuex from &#39;vuex&#39;
Vue.use(Vuex)
export default new Vue.store({
  state:{},
  mutations:{},
  action:{}
})
</code></pre>
<ul>
<li>在<code>main.js</code>中<ul>
<li>引入刚才的<code>store.js</code></li>
<li>挂载在<code>new Vue()</code>上</li>
</ul>
</li>
</ul>
<pre><code class="lang-javascript">import store from &#39;./store&#39;
new Vue({
  store  //把store挂载上来
  ...
}).$mount(&#39;#app&#39;)
</code></pre>
</li>
</ul>
<ul>
<li><p>核心概念</p>
<ul>
<li><p>State</p>
<ul>
<li><p>提供<strong>唯一的公共数据源</strong>,所有的共享数据都要统一放在<code>store</code>中的<code>State</code>中存储</p>
</li>
<li><p>比如,在<code>store.js</code>里保存一个全局数据<code>count</code></p>
<pre><code class="lang-javascript">export default new Vue.store({
  state : { count:0 }
})
</code></pre>
</li>
<li><p>在组件里访问这个数据的第一种方式</p>
<pre><code class="lang-javascript">this.$store.state.count        //js中
</code></pre>
<ul>
<li>如果是在<code>&lt;template&gt;&lt;/template&gt;</code>标签中使用插值表达式时,this可以省略</li>
</ul>
<pre><code class="lang-html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{$store.state.count}}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;            &lt;!--template标签里--&gt;
</code></pre>
</li>
<li><p>在组件里访问这个数据的第二种方式</p>
<ul>
<li><p>在<code>vuex</code>中导入<code>mapState</code>函数</p>
<pre><code class="lang-javascript">import {mapState} from &#39;vuex&#39;
</code></pre>
</li>
<li><p>把刚才导入的<code>mapState</code>函数,将当前组件需要的全局数据,映射为当前组件的<code>computed</code>计算属性,之后就可以像使用普通<code>computed</code>属性一样使用这个全局属性</p>
<pre><code class="lang-javascript">computed:{
  ...mapState([&#39;数据1&#39;,&#39;数据2&#39;,&#39;数据3&#39;])   //注意要使用&#39;...&#39;展开运算符,因为mapState匹配的是一个数组
}
</code></pre>
</li>
</ul>
</li>
<li><p>在组件里修改这个全局数据</p>
<pre><code class="lang-javascript">this.$store.state.count=1        //js中
</code></pre>
<ul>
<li>这么写确实让全局的<code>count</code>数据得到了修改,但是禁止这么写</li>
</ul>
</li>
</ul>
</li>
<li><p>要通过<code>Mutation</code>进行进行<code>Store</code>中的数据变更</p>
</li>
<li><p>Mutation</p>
<ul>
<li><p>禁止直接修改<code>Store</code>中的数据</p>
<ul>
<li>直接修改的方式<strong>无法监控</strong>数据的变化,极<strong>不利于后期维护</strong></li>
</ul>
</li>
<li><p>只能通过<code>mutation</code>修改<code>Store</code>中的数据</p>
</li>
<li><p>因为通过这种方式的操作<strong>虽然稍微繁琐一些</strong>,但是<strong>便于集中监控</strong>所有的数据变化</p>
</li>
<li><p><strong>Mutation</strong>使用的第一种方式</p>
<ul>
<li><p>在<code>Store.js</code>定义<code>Mutation</code>函数</p>
<pre><code class="lang-javascript">export default new Vue.store({
  state:{
    num:0
  },
  mutations:{
    calc(state){
      state.num++
    }
  },
  action:{}
})
</code></pre>
<ul>
<li>定义需写在<code>new Vue.store()</code>里面</li>
</ul>
</li>
<li><p>在<code>mutations</code>对象里存放着修改<code>state</code>中数据的方法</p>
<ul>
<li>每个方法都有一个<code>state</code>(形参)</li>
<li>要修改哪个属性,就在方法内对<code>state.属性名</code>进行相应的操作</li>
</ul>
</li>
<li><p>如何在组件内通过<code>Mutation</code>修改数据</p>
<ul>
<li>通过<code>this.$store.commit(&#39;方法名&#39;)</code></li>
</ul>
</li>
<li><p><code>commit(&#39;xxx&#39;)</code>的作用就是调用<code>Mutation</code>中的<code>xxx</code>方法</p>
<pre><code class="lang-html">&lt;button @click=&#39;add&#39;&gt;&lt;/button&gt;
&lt;script&gt;
export default{
 methods:{
   add(){
     this.$store.commit(&#39;calc&#39;)  
   }
 } 
}
&lt;/script&gt;
</code></pre>
</li>
<li><p>如何在调用<code>Mutation</code>时传参</p>
<ul>
<li>直接把想要其他形参写在<code>state</code>后面即可</li>
</ul>
</li>
<li><p>但是<code>state</code>必须是第一个,这些形参不能写在它前面</p>
<pre><code class="lang-javascript">export default new Vue.store({
  state:{
    num:0
  },
  mutations:{
    calc(state,形参1,形参2){
      state.num+=形参1
      console.log(形参2)
    }
  },
  action:{}
})
</code></pre>
<pre><code class="lang-html">&lt;button @click=&#39;add&#39;&gt;&lt;/button&gt;
&lt;script&gt;
export default{
 methods:{
   add(){
     this.$store.commit(&#39;calc&#39;,4,5)  
   }
 } 
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>Mutation</strong>使用的第二种方式</p>
<ul>
<li><p>通过<code>mapMutation</code>函数</p>
<ul>
<li><p>从<code>vuex</code>中引入该函数</p>
<pre><code class="lang-javascript">import {mapMutation} from &#39;vuex&#39;
</code></pre>
</li>
<li><p>通过刚才的函数,将需要的<code>Mutation</code>函数,映射为当前组件的<code>methods</code>方法</p>
<pre><code class="lang-javascript">export default{
  methods:{
    ...mapMutation([&#39;calc&#39;])  //使用...展开运算符,把数组里的所有方法都映射进来

}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在<code>Mutation</code>函数里不能直接执行<code>异步</code>操作</p>
</li>
<li><p>想要在<code>Vuex</code>中执行异步操作,要通过<code>Action</code>处理异步任务</p>
</li>
</ul>
</li>
<li><p>Action</p>
<ul>
<li><p>何时</p>
<ul>
<li>如果需要通过异步操作变更数据,必须通过<code>Action</code>,不能通过<code>Mutation</code></li>
<li>原理是在<code>Action</code>的方法里<strong>异步地</strong>触发<code>Mutation</code>方法,但是也不能执行修改</li>
</ul>
<pre><code class="lang-JavaScript">export default new Vue.store({
  state:{
    num:0
  },
  mutations:{
    calc(state){
      state.num++
    }
  },
  actions:{
    calcAnyc(content){
      setTimeout(()=&gt;{
         content.commit(&#39;calc&#39;)   //如果有异步操作,先触发action中的方法,再通过这个方法触发Mutation里的方法
      },1000)
    }
  }
})
</code></pre>
<pre><code class="lang-html">&lt;button @click=&#39;addAnyc&#39;&gt;&lt;/button&gt;
&lt;script&gt;
export default{
 methods:{
   addAnyc(){
     this.$store.dispatch(&#39;calcAnyc&#39;)  
   }
 } 
}
&lt;/script&gt;
</code></pre>
</li>
<li><p>如何带参传入</p>
<ul>
<li>和上面<code>Mutation</code>类似,把形参写在后面</li>
</ul>
<pre><code class="lang-javascript">export default new Vue.store({
  state:{
    num:0
  },
  mutations:{
    calc(state,形参1){
      state.num+=形参
    }
  },
  actions:{
    calcAnyc(content,形参1){
      setTimeout(()=&gt;{
         content.commit(&#39;calc&#39;,形参1)   //如果有异步操作,先触发action中的方法,再通过这个方法触发Mutation里的方法
      },1000)
    }
  }
})
</code></pre>
<pre><code class="lang-html">&lt;button @click=&#39;addAnyc&#39;&gt;&lt;/button&gt;
&lt;script&gt;
export default{
 methods:{
   addAnyc(){
     this.$store.dispatch(&#39;calcAnyc&#39;,形参1)  
   }
 } 
}
&lt;/script&gt;
</code></pre>
<ul>
<li><code>this.$store.dispatch(&#39;calcAnyc&#39;,形参)</code>会先把形参传给<code>Action</code>中的方法,<code>Action</code>中的方法在异步调用<code>Mutation</code>中的方法时,会把自己接收到的形参再传过去</li>
</ul>
</li>
<li><p>触发Action的另一种方式</p>
<ul>
<li><p>从<code>Vuex</code>中导入<code>mapActions</code>函数</p>
<pre><code class="lang-javascript">import {mapActions} from &#39;vuex&#39;
</code></pre>
</li>
<li><p>将指定的<code>action</code>函数,映射为当前组件的<code>methods</code>方法</p>
<pre><code class="lang-javascript">methods:{
  ...mapActions([&#39;calcAnyc&#39;])
}
</code></pre>
</li>
<li><p>像使用<code>methods</code>里的方法一样使用<code>action</code>函数,传参也一样</p>
<pre><code class="lang-html">&lt;button @click=&#39;calcAnyc&#39;&gt;&lt;/button&gt;
&lt;script&gt;
export default{
 methods:{
    ...mapActions([&#39;calcAnyc&#39;]) ,
 } 
}
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Getter</p>
<ul>
<li>什么是<ul>
<li>会对<code>Store</code>里的数据进行加工生成新的数据,类似<code>vue</code>的计算属性</li>
</ul>
</li>
<li><code>Store</code>中的数据发生变化,<code>Getter</code>里的数据也会变化</li>
</ul>
</li>
</ul>
</li>
<li><p>不会修改<code>Store</code>里的原数据</p>
</li>
</ul>
<ul>
<li><p>如何</p>
</li>
<li><p>如何定义</p>
<pre><code class="lang-javascript">export default new Vue.store({
    state:{
    num:0
    },
    getters:{
      getNum(state){
        return &#39;现在数字是&#39;+state.num
      }
    }
  })
</code></pre>
<ul>
<li><p>如何使用</p>
<pre><code class="lang-javascript">export default{
 methods:{
 showNum(){
     this.$store.getters(&#39;getNum&#39;)  
   }
 } 
} //js
</code></pre>
<pre><code class="lang-jsx">html
&lt;p&gt;{{$store.getters.getNum}}&lt;/p&gt;  &lt;!--html--&gt;
</code></pre>
<ul>
<li><p>第二种方法</p>
</li>
<li><p>引入<code>mapGetters</code></p>
<pre><code class="lang-jsx">import { mapGetters } from &#39;vuex&#39;
</code></pre>
</li>
<li><p>使用展开运算符放在<code>computed</code>属性里,当做普通<code>computed</code>属性来用</p>
<pre><code class="lang-JavaScript">computed:{
  ...mapGetters([&#39;getNum&#39;])
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="v-if-v-show-">v-if和v-show区别</h5>
<ul>
<li><p>相同</p>
<ul>
<li>都是控制元素显示和隐藏</li>
<li>都是通过一个布尔判断的返回值空值</li>
</ul>
</li>
<li><p>v-show</p>
<ul>
<li>控制的原理是<code>display:none</code></li>
<li>控制单个元素显示或者隐藏</li>
<li>适合那种根据条件变化可以不断切换<code>显示 / 隐藏</code>状态的元素</li>
</ul>
</li>
<li>v-if<ul>
<li>控制的原理是删除布尔判定值为<code>false</code>的元素</li>
<li>除此之外,可以配合<code>v-else</code>,<code>v-else-if</code>使用<ul>
<li>可以控制元素多选一显示</li>
<li>假如<code>v-if</code>条件不满足,那就进而判定<code>v-else-if</code>,都不满足就会显示<code>v-else</code>,并且把不满足的元素节点删去</li>
</ul>
</li>
<li>适合那种组件渲染之初就已经决定显示或者隐藏的情况 ,不会再反复横跳, 这种元素一旦 <code>显示 / 隐藏</code> 了基本就不再变化</li>
</ul>
</li>
</ul>
<h5 id="computed-vs-watch">computed  vs watch</h5>
<ul>
<li><p>computed</p>
<ul>
<li>只要某个变量是根据其他变量计算而得到的,就应该写在<code>computed</code>里面</li>
<li>访问和使用时,和访问普通<code>data(){ }</code>里面的数据方法一样</li>
<li><code>computed</code>里的内容不实际被存储</li>
<li>因为其内容是根据其他数据计算而得到的<ul>
<li>因此其他相关的数据发生改变时</li>
<li><code>computed</code>里的内容也会改变</li>
</ul>
</li>
<li>比如</li>
</ul>
<pre><code class="lang-jsx">export default{
  data(){
    return{
      num1:2,
      num2:3
    }
  },
  computed:{
    num3(){
      this.num1*this.num2
    }
  }
}
</code></pre>
<pre><code class="lang-jsx">&lt;div&gt;{{num3}}&lt;/div&gt;

//如果num1或者num2发生了改变  ,那么 num3 也就发生了变化
</code></pre>
</li>
<li><p>watch</p>
<ul>
<li>监控一个属性</li>
<li>只要这个属性发生了变化,就会立即调动<code>watch</code>里面的同名方法</li>
<li>比如</li>
</ul>
<pre><code class="lang-jsx">
export default{
  data(){
    return{
      num:2

    }
  },
  watch:{
    num(){
      console.log(&#39;num发生了变化&#39;)
    }
  }
}
</code></pre>
</li>
<li><p>区别</p>
<ul>
<li><code>watch</code>监控的是一个已经存在的属性,每当这个属性发生了改变,就调用相应的方法</li>
<li><code>computed</code>是根据其他属性,计算得到另一个属性,这个属性是动态计算而成,并不会实际存储</li>
</ul>
</li>
</ul>
<h5 id="beforemount-created-">beforeMount 和 created 的区别</h5>
<ul>
<li>相同点<ul>
<li>两者能做的事情基本一样<ul>
<li>都可以发送请求</li>
<li>操作<code>data</code></li>
<li>或者是调用<code>methods</code>中的一些方法</li>
<li>但是因为此时页面并没有渲染完成,并不能对页面数据绑定的内容进行<code>DOM</code>操作</li>
</ul>
</li>
</ul>
</li>
<li>不同点<ul>
<li><code>created</code>阶段中中的<code>el</code>并没有得到初始化<ul>
<li><code>el</code>就是<code>new Vue</code>对象监控的容器</li>
</ul>
</li>
<li><code>beforeMount</code>阶段中,<code>el</code>已经得到了初始化<ul>
<li>但是因为页面渲染还没有完成</li>
<li>页面上还是<code>{{ }}</code>占位符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="vue-">vue生命周期函数</h5>
<table>
<thead>
<tr>
<th>阶段</th>
<th>特点</th>
<th>能干啥</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforeCreate</td>
<td>data中的数据没有得到初始化<br />el也没有的到初始化<br /></td>
<td>不能访问数据,也不能调用方法<br />不能DOM操作</td>
</tr>
<tr>
<td>created</td>
<td>data里面的数据得到了初始化<br />el没有得到初始化<br />页面没有渲染完成</td>
<td>操作数据,手动调用方法<br />发送请求<br />但是不能DOM操作</td>
</tr>
<tr>
<td>beforeMount</td>
<td>data里面的数据得到初始化<br />el已经得到了初始化<br />但是页面还是用<code>{{ }}</code>插值表达式占位</td>
<td>操作数据,手动调用方法,<br />发送请求<br />此时依旧不能进行操作</td>
</tr>
<tr>
<td>Mounted</td>
<td>data,el得到了初始化,<br />页面也渲染完成</td>
<td>操作数据,手动调动方法,<br />发送请求,DOM操作</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td><code>view</code>层的数据发生了改变,会触发这个声明周期函数<br />如果仅仅是<code>data</code>层的数据发生了变化并不会触发这个钩子函数<br />在此完成数据被改变之前最后进行的操作</td>
<td></td>
</tr>
<tr>
<td>updated</td>
<td><code>view</code>层的数据发生了改变,会触发这个声明周期函数<br />如果仅仅是<code>data</code>层的数据发生了变化并不会触发这个钩子函数<br /></td>
<td></td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>销毁前执行</td>
<td>清除定时器,解绑数据 方法等</td>
</tr>
<tr>
<td>destoryed</td>
<td>DOM元素依旧存在,只是不再会受到<code>new Vue</code>的监控</td>
</tr>
</tbody>
</table>
<h5 id="-">介绍原型链</h5>
<ul>
<li><p>原型链其实就是控制访问对象属性和方法的一种链式关系逻辑</p>
<ul>
<li>当我们访问一个对象的成员时<ul>
<li>会优先去这个对象的自有成员中查找这个方法</li>
<li>如果没有,就会去其<code>__proto__</code>原型上面找</li>
<li>还没有,就去原型的原型<code>obj.__proto__.__proto__</code>上面找</li>
<li>直到找到顶层都没有</li>
<li>才返回<code>undefined</code></li>
</ul>
</li>
</ul>
</li>
<li><p>提到原型就不得不提到构造函数</p>
<ul>
<li>构造函数其实就是一种创建其类型 实例对象 的模板函数</li>
<li>上面储存着描述这类对象特征的 属性 </li>
<li>虽然构造函数上面也可以存储方法</li>
<li>但是如果在构造函数上存储方法<ul>
<li>这个构造函数每次被实例化一次,都重新创建这个方法一次</li>
<li>浪费性能</li>
<li>况且 <strong>代码重用</strong> 本身就是函数设定的初衷 , 这一行为有违这个初衷</li>
</ul>
</li>
<li>于是,我们使用原型对象来保存一类对象 <strong>共有</strong> 的方法</li>
</ul>
</li>
<li><p>还不得不提到面向对象的多态特征</p>
<ul>
<li><p>我们知道在<code>js</code>中,万物皆对象</p>
</li>
<li><p>最顶层的基类叫做<code>Object</code> , 任何其他的 类 其实都是<code>Object</code>的子类</p>
<ul>
<li>比如<code>String , Number , Array ,Date ...</code>等等</li>
</ul>
</li>
<li><p>有时候 , 我们想用一个方法 , 但是从父类那里继承得来的方法并非那么好用 , 不能完全满足我们的需要</p>
</li>
<li><p>我们可以利用 原型链 的成员访问优先级 原理重写这个方法</p>
<ul>
<li>把同名方法重写为自有方法,或者是保存在原型上的方法,让它不再从更高的父级那里继承而来<ul>
<li>有自有方法,就绝对不会去原型上找</li>
<li>原型上有,就绝对不会再沿着原型链再往上找</li>
<li>总之...</li>
<li>就近原则</li>
</ul>
</li>
</ul>
</li>
<li><p>也正是因此,同样是一个<code>toString( )</code>方法,在不同情况下的结果不一样 , 就是因为在设计时 , 针对不同的情况,做了不同的重写,而不是一味的继承</p>
<pre><code class="lang-jsx">对象.toString()   //[Object object]
数组.toString()   //把数组打散,并且扁平化为一段字符
数字.toString()   //字符数字
...
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="settimeout-setinterval">setTimeout 和 setInterval</h5>
<ul>
<li><p>相同</p>
<ul>
<li>都是定时器</li>
<li>定时器里的<code>this</code>一般指向<code>window</code></li>
<li>定时器里面的回调函数是异步执行的        </li>
</ul>
</li>
<li><p>不同</p>
<ul>
<li><code>setTimeout</code> 定时器里的函数 ,  只执行一次</li>
<li>而<code>setInterval</code>里的函数 , 会每隔一个时间周期就执行一次</li>
</ul>
</li>
<li><p>引出同步和异步的概念</p>
<ul>
<li><p>同步操作 </p>
<ul>
<li>前面的操作没有执行完毕 , 后续代码就不能执行</li>
</ul>
</li>
<li><p>异步操作</p>
<ul>
<li><p>在 编译 <code>js</code>代码时候,会把异步进行放在事件队列里</p>
</li>
<li><p>等主进程的同步任务执行完了,就会去执行异步任务</p>
</li>
<li><p>异步操作是无序的</p>
<ul>
<li>比如我们发送两条<code>ajax</code>请求</li>
<li>先写的那句<code>ajax</code>未必能比后写的先得到返回结果</li>
</ul>
</li>
<li><p>使得很多操作失控</p>
</li>
<li><p>如何解决</p>
<ul>
<li><p>旧方法 </p>
<ul>
<li>回调嵌套</li>
</ul>
</li>
<li><p>新方法</p>
<ul>
<li><p><code>Promise then</code> / <code>Promise (async function(){ await... })</code></p>
</li>
<li><p>比如</p>
<pre><code class="lang-jsx">//es6
var total=0
var add=function(num){
  return new Promise(function(resolve,reject){
    setTimeout(function(){
      resolve(num)
    },200)
  })
}
add(2).then(res=&gt;{
  total+=res;
  return add(3)
}).then(res=&gt;{
  total+=res;
  return add(4)
}).then(res=&gt;{
  total+=res;
  console.log(total)
})
//因为几个操作可以是并行的无必然的顺序,还可以使用Promise.all进行进一步简化
Promise.all([
  add(2),add(3),add(4)
]).then(res=&gt;{
 total=res.reduce((prev,next)=&gt;prev+next)
})
</code></pre>
<pre><code class="lang-jsx">//es7

var total=0
var add=function(num){
  return new Promise(function(resolve,reject){
    setTimeout(function(){
      resolve(num)
    },200)
  })
}
(async function(){
  var res=await Promise.all([add(2),add(3),add(4)])
  total=res.reduce((prev,next)=&gt;prev+next)
  console.log(total)
})()
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-">原生获取屏幕亮度</h5>
<ul>
<li><p><code>Luminosity API</code>用于屏幕亮度调节，当移动设备的亮度传感器感知外部亮度发生显著变化时，会触发<code>devicelight</code>事件。</p>
</li>
<li><p>目前，只有Firefox部署了这个API。</p>
<pre><code class="lang-jsx">window.addEventListener(&#39;devicelight&#39;, function(event) {
  console.log(event.value + &#39;lux&#39;);
});
</code></pre>
</li>
</ul>
<h5 id="-">前端性能优化</h5>
<ul>
<li><p>优化发送<code>ajax</code>请求</p>
<ul>
<li>使用 <strong>节流</strong> 或 <strong>防抖</strong> 等技术<ul>
<li>节流<ul>
<li>在一段时间内 , 只能发送一次请求,稀释事件的触发频率</li>
</ul>
</li>
<li>防抖<ul>
<li>在一段时间里 , 多次触发会阻止事件触发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优化静态资源</p>
<ul>
<li><p>小图或者icon 采用<code>精灵图 + 定位</code> 的方式实现加载</p>
</li>
<li><p>懒加载</p>
<ul>
<li>给<code>图片 / 视频</code>等<code>src</code>设置为空</li>
<li>将路径写在一个自定义属性里</li>
<li>每次页面加载或者<code>onscrll</code>(也就是滚动时候) 都会进行判断</li>
<li>根据 用户设备 <strong>一屏的高度</strong> 和 <strong>图片出现距屏幕上边沿的</strong> 距离 判断图片是否已经进入用户视野</li>
<li>进入用户视野的图片,再把自定义事件里的路径赋值给<code>src</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>webpack</code>打包工具,把众多<code>css js</code> 文件进行打包 ,缩小项目体积</p>
</li>
<li><p><code>js</code>文件引用放在<code>css</code>后</p>
<ul>
<li>浏览器会根据<code>css</code>和<code>html</code>代码生成<code>Render Tree</code>来渲染页面</li>
<li>但是遇到<code>&lt;script&gt;&lt;/script&gt;</code>就会阻塞页面渲染</li>
</ul>
</li>
<li><p>别用<code>table</code>布局</p>
<ul>
<li>否则很小的<code>DOM</code>操作,就可能导致页面的重排重绘</li>
</ul>
</li>
<li><p>使用事件委托</p>
<ul>
<li>如果一系列平级的<code>DOM</code>元素都可以触发事件</li>
<li>不要给他们每个都绑定事件</li>
<li>而是给它们的 <strong>父级元素</strong> 绑定事件<ul>
<li>到时候根据事件对象判断 触发事件的元素是哪一个</li>
<li>再执行相应操作</li>
</ul>
</li>
</ul>
</li>
<li><p>优化<code>DOM</code>操作</p>
<ul>
<li>比如有些时候,我们进行一系列增加页面元素的<code>DOM</code>操作</li>
<li>如果每次让他们一个一个执行</li>
<li>每次新增一个<code>DOM</code>元素,页面就会重排重绘一次</li>
<li>可以把这些新增的元素统一写在一个 <strong>数组</strong>里</li>
<li>增加完成后, 打散这个数组, 一次性渲染到页面上</li>
</ul>
</li>
<li><p>组件化开发中</p>
<ul>
<li><p>组件模块化 按需引入</p>
<ul>
<li><p>比如我们只想用<code>MintUI</code>的提示框功能</p>
</li>
<li><p>就不要整个引入<code>MintUI</code></p>
</li>
<li><p>而是按需引入</p>
<pre><code class="lang-jsx">//举个例子
import { toast } from &#39;./MintUI&#39;
</code></pre>
</li>
</ul>
</li>
<li><p>组件开发中,组件也使用懒加载进行优化</p>
</li>
</ul>
</li>
<li><p>递归比较消耗性能 , 如果一个功能可以使用循环完成,就不要使用递归</p>
</li>
</ul>
<h5 id="-">前端安全优化</h5>
<ul>
<li>使用<code>post</code>发送请求</li>
<li>输入合法性验证<ul>
<li>判定用户输入的内容是否符合预期的格式</li>
</ul>
</li>
<li>对服务器端输出到浏览器的数据进行编码或转义<ul>
<li>相应的<code>JavaScript</code>的编码方式可以使用<code>JavascriptEncode</code></li>
</ul>
</li>
<li><code>Web</code>应用程序在设置<code>cookie</code>时，将其属性设为<code>HttpOnly</code><ul>
<li>涉及到重要信息的数据,不要保存在<code>cookie</code>里</li>
</ul>
</li>
<li>适当使用<strong>验证码</strong></li>
<li>使用拦截器验证权限</li>
</ul>
<h5 id="-">主流布局方式</h5>
<ul>
<li><p>流式布局</p>
<ul>
<li>特点<ul>
<li>给定义一个高度</li>
<li>宽度采用百分比的方式</li>
<li>但是因为还是有给定的高度和文字大小<ul>
<li>导致在一些比较极端的设备下,显示效果不尽人意</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>瀑布流式布局</p>
<ul>
<li><p>特点</p>
<ul>
<li><p>不定高</p>
</li>
<li><p>内容多的容器就高度就大 , 否则就小</p>
</li>
<li><p>因此就形成了参差不齐,类似瀑布状的结构</p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1585789986822.png" alt="1585789986822"></p>
</li>
<li><p>实现方式</p>
<pre><code class="lang-css">.container{
    width: 1200px;
    margin:20px auto;
    columns: 4;
    column-gap:40px;
    height: 100%;
}
.container&gt;.box{
    width:100%;
    margin:0 0 20px;
    padding: 10px;
    background-color: #fff;
    break-inside:avoid;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>响应式布局</p>
<ul>
<li><p>特性</p>
<ul>
<li>根据设备的不同,给予不同的样式和 布局 方式</li>
</ul>
</li>
<li><p>如何实现</p>
<ul>
<li><p>可以手写媒体查询</p>
<pre><code class="lang-css">@media (max-width: 1200px){
        .container{
        columns: 3;
        width:calc(100%-40px);
        box-sizing: border-box;
        padding: 10px;}
}
@media (max-width: 768px){
        .container{
        columns: 2;
        }
}
@media (max-width: 448px){
        .container{
        columns: 1;
        }
}
</code></pre>
</li>
<li><p>或者使用<code>bootStrap</code>等已经写好了媒体查询的样式库</p>
<pre><code class="lang-jsx">&lt;div class=&#39;col-md-4 col-lg-3&#39;&gt;&lt;/div&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-event-loop-">事件循环和事件队列(event loop)</h5>
<ul>
<li><code>JavaScript</code>是<strong>单线程</strong>的<ul>
<li>前一个任务完成 , 才会去执行后一个任务</li>
<li>如果前一个任务很耗时 , 那么后一个任务就不能得到执行</li>
</ul>
</li>
<li>为了解决这个问题 , 在<code>js</code>出现了<strong>同步操作</strong>和<strong>异步操作</strong><ul>
<li>同步操作<ul>
<li>在主线程( <code>stack</code> )上顺次执行的操作,只有前一项任务执行完毕了,后一项任务才会去执行</li>
</ul>
</li>
<li>异步操作<ul>
<li>不进入主线程</li>
<li>进入 <strong>任务队列</strong> 中等待</li>
<li>只有 <strong>任务队列</strong> 通知主线程 这个任务可以执行了<ul>
<li>这个任务才会去进入主线程执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/9418222-3ee70117afb9a5d1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1148/format/webp" alt="img"></p>
<ul>
<li><p>结合这张图,我们总体梳理一下流程</p>
<ul>
<li>所有的 同步任务 都在<strong>主线程</strong> 执行 , 形成一个执行栈<ul>
<li>同步任务 入栈</li>
<li>同步任务 得到执行</li>
<li>同步任务 出栈</li>
</ul>
</li>
<li>在 <strong>主线程</strong> 之外 , 还有一个 <strong>任务队列</strong> (<code>task queue</code>)<ul>
<li>只要 <strong>异步任务</strong> 有了执行结果 ,先不入栈</li>
<li>在 <strong>任务队列</strong> 中 放置一个事件 </li>
</ul>
</li>
<li>当 <strong>主线程</strong> 中所有的同步任务执行完了<ul>
<li>就会去读取 <strong>任务队列</strong></li>
<li>查看 刚才注册的 <strong>事件</strong></li>
<li>那些 <strong>事件</strong> 对应的 <strong>异步任务</strong> 结束等待状态 , <strong>入栈</strong> 执行</li>
</ul>
</li>
<li>主线程会不断地 重复上述 <strong>三步操作</strong><ul>
<li>主线程从 <strong>任务队列</strong> 中读取事件,这个过程是不断循环的</li>
<li>因此整个运行机制称为 <strong>事件循环</strong> (<code>event loop</code>)</li>
</ul>
</li>
</ul>
</li>
<li><p>关于 <strong>宏任务</strong> 和 <strong>微任务</strong></p>
<ul>
<li><p>宏任务</p>
<ul>
<li>每次在 <strong>栈</strong>  中执行的任务</li>
<li>每次会把 <strong>任务代码</strong> 从头到尾执行完毕</li>
<li>期间不会去执行其他任务</li>
<li>包括<code>script,setTimeout,setInterval</code> </li>
</ul>
</li>
<li><p>微任务</p>
<ul>
<li>当前 任务 执行完毕后 <strong>立刻执行</strong> 的函数</li>
<li>包括<code>promise中的then(),process.nextTick</code></li>
</ul>
</li>
<li><p>执行过程</p>
<ul>
<li>执行 整体代码( <strong>宏任务</strong> )后，开始第一次循环</li>
<li>接着执行所有的 <strong>微任务</strong></li>
<li>然后再次从<strong>宏任务</strong>开始，找到其中一个任务队列执行完毕</li>
<li>再执行所有的<strong>微任务</strong></li>
<li>...</li>
<li>循环往复</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
</li>
</ul>
</li>
<li><p>以一道例题来分析说明</p>
<pre><code class="lang-jsx">
setTimeout(function(){
    console.log(&#39;1&#39;)
});

new Promise(function(resolve){
    console.log(&#39;2&#39;);
  resolve();
}).then(function(){
    console.log(&#39;3&#39;)
});

console.log(&#39;4&#39;)

</code></pre>
<ul>
<li>分析这段代码<ul>
<li>我们这段代码整体是个 <strong>宏任务</strong><ul>
<li>把这个任务 <strong>从头到尾</strong> 执行完毕<ul>
<li>到了<code>setTimeout(function(){console.log(&#39;1&#39;)})</code>时,发现是异步任务,暂不入栈,放到任务队列里等待</li>
<li>到了<code>new Promise</code>,同步任务,立刻执行 ,打印<code>2</code><ul>
<li><code>promise</code>是为了解决异步任务无序调用而生的,其本身是<strong>同步</strong>的</li>
</ul>
</li>
<li>到了<code>then( )</code>加入 <strong>微任务</strong> 队列 ,等待本次宏任务执行完毕后 立刻执行</li>
<li>到了<code>console.log(4)</code> ,同步任务,立刻执行</li>
</ul>
</li>
</ul>
</li>
<li>第一次 <strong>宏任务</strong> 执行完毕</li>
<li>会去执行所有的<strong>微任务</strong><ul>
<li>因此执行刚才的微任务<code>then()</code>任务,打印<code>3</code></li>
</ul>
</li>
<li>微任务执行完毕后,刚才任务队里的定时器 <strong>入栈</strong></li>
<li>执行,结果是打印<code>1</code></li>
</ul>
</li>
</ul>
</li>
<li><p>分析一道更难的题</p>
<pre><code class="lang-jsx">console.log(1);

setTimeout(() =&gt; {
  console.log(2);
  Promise.resolve().then(() =&gt; {
    console.log(3)
  });
});

new Promise((resolve, reject) =&gt; {
  console.log(4)
  resolve(5)
}).then((data) =&gt; {
  console.log(data);
})

setTimeout(() =&gt; {
  console.log(6);
})

console.log(7);
</code></pre>
<ul>
<li>分析这段代码<ul>
<li>代码整体是 <strong>宏任务</strong><ul>
<li><strong>从头到尾</strong>执行完毕<ul>
<li>到了<code>console.log(1)</code>,同步任务,立刻执行 ,打印<code>1</code></li>
<li>到了<code>setTimeout()</code>这里 , 异步任务先加入任务队列里等待执行</li>
<li>到了<code>promise</code>这里 ,同步任务,立刻执行,打印<code>4</code></li>
<li>到了<code>then( )</code>这里,将<code>then</code>加入微任务队列,等待本次宏任务执行完了,会立刻执行</li>
<li>到了<code>setTimeout()</code>这里,继续加入任务队里,等待</li>
<li>到了<code>console.log(7)</code>,直接打印<code>7</code></li>
</ul>
</li>
</ul>
</li>
<li>本次<strong>宏任务</strong>结束了,会立刻执行所有<strong>微任务</strong></li>
<li>所以会执行刚才的<code>then</code>,打印<code>promise</code>传来的<code>5</code></li>
<li>之后 <strong>事件队列</strong> 里的宏任务依次 <strong>入栈</strong></li>
<li>先是之前第一个定时器里的函数<ul>
<li><code>console.log(2)</code>,会立刻打印<code>2</code></li>
<li>然后会将<code>then(console.log(3))</code>加入<strong>微任务</strong> 中,等待本次宏任务结束了,立刻执行</li>
<li>本次宏任务至此完毕</li>
</ul>
</li>
<li>立刻执行所有 <strong>微任务</strong> ,打印<code>3</code></li>
<li>队列里下一个宏任务入栈执行 ,也就是我们第二个定时器,打印<code>6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="-">解决跨域问题</h5>
<ul>
<li><p>同源策略</p>
<ul>
<li>浏览器 <strong>最核心</strong>,<strong>最基本</strong>的安全功能</li>
<li>所谓的同源<ul>
<li>协议</li>
<li>域名</li>
<li>端口</li>
<li>三者必须相同 ,否则就是跨域</li>
</ul>
</li>
<li>同源策略限制以下行为<ul>
<li><code>ajax</code>发送</li>
<li><code>Cookie</code>,<code>localStroage</code>,<code>IndexDB</code>读取不能</li>
<li><code>DOM</code>和<code>js</code>对象无法发送</li>
</ul>
</li>
</ul>
</li>
<li><p>跨域的方式</p>
<ul>
<li><p>跨域资源共享( <strong>CORS</strong> )</p>
<ul>
<li><p>目前的主流方式</p>
</li>
<li><p>假如不带<code>cookie</code>,前端不需要管</p>
</li>
<li><p>后端 ( <code>Node.JS</code>写法,其他语法各有各的写法 )</p>
<pre><code class="lang-jsx">var http = require(&#39;http&#39;);
var server = http.createServer();
var qs = require(&#39;querystring&#39;);

server.on(&#39;request&#39;, function(req, res) {
    var postData = &#39;&#39;;

    // 数据块接收中
    req.addListener(&#39;data&#39;, function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener(&#39;end&#39;, function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie
            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）
            /* 
             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
             */
            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的作用是让js无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen(&#39;8080&#39;);
console.log(&#39;Server is running at port 8080...&#39;);
</code></pre>
</li>
<li><p>假如需要带<code>cookie</code>,前端也需要设置一下</p>
<pre><code class="lang-jsx">//原生ajax 发请求时加上
xhr.withCredentials = true;

//jq ajax
$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});

//axios
axios.defaults.withCredentials = true
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>jsonp 方式</p>
<ul>
<li><p>特点 </p>
<ul>
<li><strong>前后端</strong> 均需配置</li>
<li>只能用于<code>get</code>请求</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>把<code>js</code>,<code>css</code>,<code>img</code>等 <strong>静态资源</strong> 分离到一台 独立域名的 服务器上</li>
<li>在<code>html</code>页面中再通过相应的标签从不同域名下加载静态资源 , 而被浏览器允许</li>
<li>因此可以通过动态创建<code>script</code>，再请求一个带参网址实现跨域通信</li>
</ul>
</li>
<li><p>如何</p>
<ul>
<li><p>前端</p>
<pre><code class="lang-jsx">//原生
 var script = document.createElement(&#39;script&#39;);
    script.type = &#39;text/javascript&#39;;

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = &#39;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#39;;
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }

//jq
$.ajax({
    url: &#39;http://www.domain2.com:8080/login&#39;,
    type: &#39;get&#39;,
    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp
    jsonpCallback: &quot;handleCallback&quot;,    // 自定义回调函数名
    data: {}
});

//vue
this.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, {
    params: {},
    jsonp: &#39;handleCallback&#39;
}).then((res) =&gt; {
    console.log(res); 
})
</code></pre>
</li>
<li><p>后端 ( <code>Node.JS</code> )</p>
<pre><code class="lang-jsx">var querystring = require(&#39;querystring&#39;);
var http = require(&#39;http&#39;);
var server = http.createServer();

server.on(&#39;request&#39;, function(req, res) {
    var params = qs.parse(req.url.split(&#39;?&#39;)[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { &#39;Content-Type&#39;: &#39;text/javascript&#39; });
    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);

    res.end();
});

server.listen(&#39;8080&#39;);
console.log(&#39;Server is running at port 8080...&#39;);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="call-apply-bind">call、apply和bind</h5>
<ul>
<li><p>call 和 apply</p>
<ul>
<li><p>相同点</p>
<ul>
<li>都是可以临时改变函数<code>this</code>指向 <ul>
<li>也就是说只在使用<code>apply / call</code>的这次调用时更改</li>
</ul>
</li>
<li>同时可以传入参数</li>
<li>都会立刻调用函数</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li><code>call</code>传入是一个一个独立的</li>
<li><code>apply</code>以数组的方式进行传入</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>当传入的参数个数较少时,两者性能相差无几</li>
<li>当传入的参数个数较多时,<code>call</code>的性能更好些</li>
</ul>
</li>
<li><p><code>call</code>如何传数组</p>
<pre><code class="lang-jsx">let arr=[2,3,4,5]
function fn(){
  console.log(this)
  console.log(arguments)
}
fn.call(arr,...arr)
</code></pre>
<ul>
<li>使用展开运算符传参,会把数组打散,并且把每一项单独传入</li>
</ul>
</li>
</ul>
</li>
<li><p>bind</p>
<ul>
<li>和<code>apply / call</code>的共同点<ul>
<li>都是可以更改函数的<code>this</code>指向</li>
<li>也可以传参</li>
</ul>
</li>
<li>不同点<ul>
<li><code>bind</code>其实可以理解成是一个函数的预处理机制 </li>
<li>也就是说在函数调用前 , 就把函数里的<code>this</code>,以及参数问题处理好<ul>
<li>永久替换<code>this</code>指向</li>
<li>使用<code>bind</code>不会调用函数</li>
</ul>
</li>
</ul>
</li>
<li>何时使用<ul>
<li>需要更改<code>this</code>但是不能调用函数的情况</li>
<li>需用永久替换<code>this</code>的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="localstorage-cookie">localStorage 和 cookie</h5>
<ul>
<li><p>cookie</p>
<ul>
<li><p><code>cookie</code>的特性</p>
<ul>
<li>存储在浏览器中,方便用户和程序员操作</li>
<li>但是也因为存在客户端中,导致容易被恶意截取,夺取用户信息 ,不安全</li>
<li>大小有限制<ul>
<li><code>cookie</code>文本的大小一般为<code>4kb</code></li>
<li>每个站点只能容纳<code>20</code>个<code>cookie</code></li>
</ul>
</li>
</ul>
</li>
<li><p>添加</p>
<pre><code class="lang-jsx">//把cookie保存 封装为一个函数
function setCookie (name, value) {
if(!name||!value)return
var days = 1; //定义一天
var exp = new Date();
exp.setTime(exp.getTime() + days * 24 * 60 * 60 * 1000);
// 写入Cookie, toGMTString将时间转换成字符串
document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString;
};

//每次获取时,直接调用这个函数
setCookie(&#39;uname&#39;,&#39;tom&#39;)

</code></pre>
</li>
<li><p>获取</p>
<pre><code class="lang-jsx">//把cookie读取 封装为一个函数
function getCookie (name) {
var arr,reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); //匹配字段
if (arr = document.cookie.match(reg)) {
return unescape(arr[2]);
} else {
return null;
}
}
//每次读取时,直接调用这个函数
getCookie(&#39;uname&#39;)
</code></pre>
</li>
</ul>
</li>
<li><p>localStroage</p>
<ul>
<li><p>特性</p>
<ul>
<li>储存和读取的方法比<code>cookie</code>还要简单</li>
<li>永久存储,只要不手动去删,就不会丢失</li>
<li>大小限制为<code>5M</code>,这对信息数据来说,是相当大的空间了,但是也更加消耗性能</li>
<li>属于<code>HTML5</code>的新特性 , <code>IE8</code>以下不能用</li>
<li>如果浏览器处于 <strong>隐私模式</strong> 时,不能获取 , 同时也不会被 <strong>爬虫</strong> 抓取到</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li><p>增 , 改</p>
<pre><code class="lang-jsx">//在写入时要 标注键名和键值
localStorage.setItem(&#39;键名&#39;,键值)
</code></pre>
</li>
<li><p>查</p>
<pre><code class="lang-jsx">console.log(localStorage.getItem(&#39;键名&#39;))
</code></pre>
</li>
<li><p>删</p>
<pre><code class="lang-jsx">localStorage.removeItem(&quot;键名&quot;);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>session</p>
<ul>
<li>特性<ul>
<li>保存在服务器里</li>
<li>安全性相对高一些</li>
<li>常用于保存 <strong>用户名</strong> 等信息</li>
<li>保存的信息是跨页面全局性的</li>
<li>能够存储任何类型,包括自定义对象,每个客户端的<code>session</code>都是独立存储的</li>
<li>当会话结束时, 服务器就会清除<code>session</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="js-">js执行和页面渲染是否可以同时运行</h5>
<ul>
<li>浏览器渲染页面的过程<ul>
<li>根据<code>HTML</code>结构生成<code>DOM树</code></li>
<li>根据<code>CSS</code>生成<code>CSS对象模型</code></li>
<li>把两者结合生成<code>Render Tree</code></li>
<li>浏览器会根据<code>RenderTree</code>进行绘制</li>
<li>但是遇到<code>&lt;script&gt;&lt;/script&gt;</code>时<ul>
<li>执行里面内容</li>
<li>阻塞页面渲染</li>
</ul>
</li>
</ul>
</li>
<li>可对前端性能进行优化<ul>
<li>详见 <strong><em>前端性能优化</em></strong> 篇</li>
</ul>
</li>
</ul>
<h5 id="-">重排重绘</h5>
<ul>
<li><p>reflow ( 重排 )</p>
<ul>
<li><p>是什么</p>
<ul>
<li>浏览器为了重新渲染部分或整个页面</li>
<li>重新计算页面元素位置和几何结构的进程叫做<code>reflow</code>.</li>
</ul>
</li>
<li><p>有何影响</p>
<ul>
<li><code>reflow</code>是导致<code>DOM</code>脚本执行效率低的关键因素之一</li>
<li>页面上任何一个节点触发了<code>reflow</code>会导致它的子节点及祖先节点重新渲染。</li>
</ul>
<p>| 何时触发重排                             |
| ---------------------------------------- |
| 改变窗口大小                             |
| 改变文字大小                             |
| 添加/删除样式表                          |
| 内容的改变，(用户在输入框中写入内容也会) |
| 激活伪类，如:hover                       |
| 操作class属性                            |
| 脚本操作DOM                              |
| 计算offsetWidth和offsetHeight            |
| 设置style属性                            |</p>
</li>
<li><p>如何优化</p>
<ul>
<li>如果是添加多个<code>DOM</code>节点 , 不要一条一条的添加<ul>
<li>把他们装进一个数组里 , 将数组打散一次性添加进去 , 这样页面就只重排一次</li>
</ul>
</li>
<li>如果一个<code>DOM</code>节点的样式可能会变化很多 , 也不要使用<code>style</code>属性一个一个地修改<ul>
<li>事先定义好一个样式<code>class</code> , 使用时直接切换<code>className</code></li>
</ul>
</li>
<li>不要把<code>DOM</code>元素的属性放在循环里作为循环变量</li>
<li>不要使用<code>table</code>布局 <ul>
<li>很小的改动 , 可能就会导致重排</li>
<li>而且也难看呀</li>
</ul>
</li>
<li>如果一个<code>DOM</code>元素确实需要很复杂的操作<ul>
<li>可以先把它<code>display:none</code></li>
<li>修改完毕后</li>
<li>再显示到页面上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>repaints ( 重绘 )</p>
<ul>
<li><p>是什么</p>
<ul>
<li>元素的<code>background-color</code>,<code>opacity</code>,<code>color</code>等属性发生变化了</li>
<li>不会影响其在页面的位置和页面的结构</li>
<li>浏览器只会用新的样式来绘制这个元素</li>
<li>这个过程叫做<code>repaints</code></li>
</ul>
<p>| 常见的重绘元素  |                  |                     |                   |
| --------------- | ---------------- | ------------------- | ----------------- |
| color           | border-style     | visibility          | background        |
| text-decoration | background-image | background-position | background-repeat |
| outline-color   | outline          | outline-style       | border-radius     |
| outline-width   | box-shadow       | background-size     |                   |</p>
</li>
</ul>
</li>
</ul>
<h5 id="-">盒子模型</h5>
<ul>
<li><p>W3C盒子模型</p>
<p><img src="https://img4.sycdn.imooc.com/5b73f51e00015f7907740523.jpg" alt="https://img4.sycdn.imooc.com/5b73f51e00015f7907740523.jpg"></p>
<ul>
<li>如何计算<ul>
<li>根据<code>W3C</code>的规范，元素内容占据的空间是由 <code>width</code> 属性设置的</li>
<li>而内容周围的 <code>padding</code>和 <code>border</code> 值是另外计算的；</li>
<li>即在标准模式下的盒模型<ul>
<li>盒子实际内容（content）的width/height以内容为标准<ul>
<li>等于我们设置的width/height</li>
</ul>
</li>
<li>盒子总宽度/高度=width/height+padding+border+margin</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>IE盒子模型</p>
<p><img src="https://img1.sycdn.imooc.com/5b73f53f0001a7ec07610507.jpg" alt="https://img1.sycdn.imooc.com/5b73f53f0001a7ec07610507.jpg"></p>
<ul>
<li>如何计算<ul>
<li>在该模式下，浏览器的<code>width</code> 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和</li>
<li>我们设置的<code>width</code>(height也是如此)以边框为标准<ul>
<li>等于盒子的内容宽度/高度+内边距padding+边框border宽度/高度</li>
</ul>
</li>
<li>盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin</li>
</ul>
</li>
</ul>
</li>
<li><p>如何相互转换</p>
<pre><code class="lang-jsx">box-sizing:border-box/content-box
</code></pre>
</li>
</ul>
<h5 id="git-">GIT基础速查</h5>
<ul>
<li>什么是<ul>
<li>一个版本控制工具</li>
<li>一个面向开源以及私有的项目托管平台</li>
</ul>
</li>
<li><p>前提</p>
<ul>
<li>安装<ul>
<li>git 官方软件</li>
<li>一路下一步</li>
</ul>
</li>
<li>启动<ul>
<li>git bash <ul>
<li>支持<code>linux</code>命令的控制台 , 一般我们使用这个</li>
</ul>
</li>
<li>git CMD<ul>
<li>支持<code>windows</code>命令的控制台</li>
</ul>
</li>
<li>git gui<ul>
<li><code>git</code>的可视化界面</li>
</ul>
</li>
</ul>
</li>
<li>可在<code>vs code</code>安装<code>git</code>插件</li>
<li>需要在<code>git</code>官网注册一个账号</li>
<li>需要一个密钥,不然不能从暂存区提交到<code>gitHub</code>仓库<ul>
<li>如果想从暂存区提交内容到<code>git</code>仓库,需要<code>git</code>授权的<code>shh</code>密钥<ul>
<li>输入<code>ssh-keygen -t rsa -C &quot;你git的邮箱地址&quot;</code></li>
</ul>
</li>
<li>去如下目录结构里找密匙 <ul>
<li>我的电脑 <ul>
<li>用户 / <code>user</code><ul>
<li>用户名文件夹<ul>
<li><code>.ssh</code>(隐藏文件夹)<ul>
<li><code>xxx.pub</code> (存有密钥)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>用编译器打开密匙文件,复制</li>
<li>在<code>gitHub</code>网站里的<code>setting</code>中</li>
<li>选择<code>SSH and GPG keys</code>新增一个密匙</li>
</ul>
</li>
</ul>
</li>
<li><p>具体操作</p>
<ul>
<li><p>创建一个文件夹</p>
</li>
<li><p>通过<code>cd</code>或者其他方式进入当前文件夹</p>
</li>
<li><p>配置<code>git</code>的基础信息 ( 前提是你得有账号[手动滑稽~] )</p>
<pre><code class="lang-cmd">git config --global user.name &quot;你的用户名&quot;
</code></pre>
<pre><code class="lang-cmd">git config --global user.email &quot;你的邮箱&quot;
</code></pre>
<ul>
<li>一般来说 , 会没有消息提示<ul>
<li>在<code>git</code>中,没有消息就是好消息</li>
</ul>
</li>
</ul>
</li>
<li><p>将工作区的内容先存在暂存区</p>
<ul>
<li>暂存区?<ul>
<li>一个虚拟的仓库</li>
</ul>
</li>
<li>如何创建暂存区<ul>
<li>进入要操作的文件夹</li>
<li><code>git init</code>初始化当前操作</li>
<li>会发现当前文件夹下多了一个<code>.git</code>文件夹<ul>
<li>这个文件夹存储的就是当前项目文件夹下所有的版本信息</li>
</ul>
</li>
</ul>
</li>
<li>如何从工作区到暂存区<ul>
<li>首先<code>git add</code><ul>
<li><code>git add 文件名</code>是只提交一个文件</li>
<li><code>git add *</code>是提交当前目录下所有文件</li>
</ul>
</li>
<li>然后再<code>git commit -m &quot;对这一次提交的描述&quot;</code></li>
</ul>
</li>
<li>其他操作<ul>
<li>查看当前工作区的状态<ul>
<li><code>git status</code></li>
<li>如果确实成功提交的话,会提示<code>nothing to commit</code></li>
</ul>
</li>
<li>如何将工作区的文件恢复至暂存区保存的状态<ul>
<li><code>git checkout</code></li>
</ul>
</li>
<li>每次发生变化时,如何判断是工作区的哪个文件相对于暂存区被修改了<ul>
<li><code>git diff</code></li>
<li>会告诉你具体改变了什么</li>
</ul>
</li>
<li>查看每次我们提交的历史版本<ul>
<li><code>git log</code></li>
<li>恢复到某个具体版本<ul>
<li><code>git reset --hard HEAD^</code>回退一个版本</li>
<li><code>git reset --hard HEAD^^</code>回退两个版本</li>
<li><code>git reset --hard 版本号</code>回退到某一具体版本<ul>
<li>版本号可在<code>git log</code>里面去查</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>清屏操作<ul>
<li><code>clear</code></li>
</ul>
</li>
<li>从远程仓库克隆项目到本地<ul>
<li><code>git clone 仓库地址</code></li>
</ul>
</li>
<li>从远程仓库更新项目到本地<ul>
<li><code>git pull</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>再把暂存区的内容存放在<code>gitHub</code>远程仓库</p>
<ul>
<li>创建远程仓库<ul>
<li>在<code>git</code>官网,右上角有一个加号<code>+</code></li>
<li>点击加号<code>+</code>后选择 <code>create a new repository</code><ul>
<li>输入远程仓库的名称</li>
<li><code>description</code> (描述)</li>
<li><code>public / private</code> (公开/私有)<ul>
<li>鼓励开源</li>
<li>希望私有的话 , 要收费</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进入刚才创建的远程仓库,<strong>拷贝</strong> <code>git</code>给出的当前仓库的地址</li>
<li>输入<code>git remote add origin 刚才复制的仓库地址</code></li>
<li>输入<code>git push -u origin master</code>进行提交<ul>
<li>在提交过程中可能要求输入用户名和密码</li>
</ul>
</li>
<li>提交成功</li>
<li>刷新远程仓库,发现已经提交成功</li>
<li>如果当前提交文件夹下有一个<code>readme.md</code>自述文件的话,还会被当成<code>html</code>片段显示在当前仓库中予以说明</li>
</ul>
</li>
</ul>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>